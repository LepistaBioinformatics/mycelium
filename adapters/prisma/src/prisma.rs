// Code generated by Prisma Client Rust. DO NOT EDIT

#![allow(warnings, unused)]
pub static DATAMODEL_STR : & 'static str = include_str ! ("/home/sgelias/thirdparty-projects/mycelium/adapters/prisma/src/schema.prisma") ;
static DATABASE_STR: &'static str = "postgresql";
pub async fn new_client(
) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
    PrismaClient::_builder().build().await
}
pub async fn new_client_with_url(
    url: &str,
) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
    PrismaClient::_builder()
        .with_url(url.to_string())
        .build()
        .await
}
pub mod user {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::StartsWith(
                value,
            ))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("id")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("id")
            }
        }
    }
    pub mod username {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUsername(value.0)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::Username(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Username(_prisma::read_filters::StringFilter::Equals(
                value,
            ))
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Username(_prisma::read_filters::StringFilter::InVec(
                value,
            ))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Username(_prisma::read_filters::StringFilter::NotInVec(
                value,
            ))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Username(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Username(_prisma::read_filters::StringFilter::Lte(
                value,
            ))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Username(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Username(_prisma::read_filters::StringFilter::Gte(
                value,
            ))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Username(_prisma::read_filters::StringFilter::Contains(
                value,
            ))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Username(
                _prisma::read_filters::StringFilter::StartsWith(value),
            )
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Username(_prisma::read_filters::StringFilter::EndsWith(
                value,
            ))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Username(_prisma::read_filters::StringFilter::Mode(
                value,
            ))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Username(_prisma::read_filters::StringFilter::Not(
                value,
            ))
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Username(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("username")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Username(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("username")
            }
        }
    }
    pub mod email {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetEmail(value.0)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::Email(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::EmailEquals(value).into()
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Email(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Email(_prisma::read_filters::StringFilter::NotInVec(
                value,
            ))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Email(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Email(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Email(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Email(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Email(_prisma::read_filters::StringFilter::Contains(
                value,
            ))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Email(_prisma::read_filters::StringFilter::StartsWith(
                value,
            ))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Email(_prisma::read_filters::StringFilter::EndsWith(
                value,
            ))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Email(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Email(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Email(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("email")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Email(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("email")
            }
        }
    }
    pub mod first_name {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetFirstName(value.0)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::FirstName(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::FirstName(_prisma::read_filters::StringFilter::Equals(
                value,
            ))
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::FirstName(_prisma::read_filters::StringFilter::InVec(
                value,
            ))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::FirstName(
                _prisma::read_filters::StringFilter::NotInVec(value),
            )
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::FirstName(_prisma::read_filters::StringFilter::Lt(
                value,
            ))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::FirstName(_prisma::read_filters::StringFilter::Lte(
                value,
            ))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::FirstName(_prisma::read_filters::StringFilter::Gt(
                value,
            ))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::FirstName(_prisma::read_filters::StringFilter::Gte(
                value,
            ))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::FirstName(
                _prisma::read_filters::StringFilter::Contains(value),
            )
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::FirstName(
                _prisma::read_filters::StringFilter::StartsWith(value),
            )
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::FirstName(
                _prisma::read_filters::StringFilter::EndsWith(value),
            )
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::FirstName(_prisma::read_filters::StringFilter::Mode(
                value,
            ))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::FirstName(_prisma::read_filters::StringFilter::Not(
                value,
            ))
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::FirstName(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("first_name")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::FirstName(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("first_name")
            }
        }
    }
    pub mod last_name {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetLastName(value.0)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::LastName(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::LastName(_prisma::read_filters::StringFilter::Equals(
                value,
            ))
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::LastName(_prisma::read_filters::StringFilter::InVec(
                value,
            ))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::LastName(_prisma::read_filters::StringFilter::NotInVec(
                value,
            ))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::LastName(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::LastName(_prisma::read_filters::StringFilter::Lte(
                value,
            ))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::LastName(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::LastName(_prisma::read_filters::StringFilter::Gte(
                value,
            ))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::LastName(_prisma::read_filters::StringFilter::Contains(
                value,
            ))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::LastName(
                _prisma::read_filters::StringFilter::StartsWith(value),
            )
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::LastName(_prisma::read_filters::StringFilter::EndsWith(
                value,
            ))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::LastName(_prisma::read_filters::StringFilter::Mode(
                value,
            ))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::LastName(_prisma::read_filters::StringFilter::Not(
                value,
            ))
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::LastName(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("last_name")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::LastName(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("last_name")
            }
        }
    }
    pub mod is_active {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetIsActive(value.0)
            }
        }
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::IsActive(direction)
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::IsActive(_prisma::read_filters::BoolFilter::Equals(
                value,
            ))
        }
        pub fn not(value: bool) -> WhereParam {
            WhereParam::IsActive(_prisma::read_filters::BoolFilter::Not(value))
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::IsActive(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("is_active")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::IsActive(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("is_active")
            }
        }
    }
    pub mod created {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(
            pub  ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        );
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreated(value.0)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::Created(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Created(_prisma::read_filters::DateTimeFilter::Equals(
                value,
            ))
        }
        pub fn in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            >,
        ) -> WhereParam {
            WhereParam::Created(_prisma::read_filters::DateTimeFilter::InVec(
                value,
            ))
        }
        pub fn not_in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            >,
        ) -> WhereParam {
            WhereParam::Created(
                _prisma::read_filters::DateTimeFilter::NotInVec(value),
            )
        }
        pub fn lt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Created(_prisma::read_filters::DateTimeFilter::Lt(
                value,
            ))
        }
        pub fn lte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Created(_prisma::read_filters::DateTimeFilter::Lte(
                value,
            ))
        }
        pub fn gt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Created(_prisma::read_filters::DateTimeFilter::Gt(
                value,
            ))
        }
        pub fn gte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Created(_prisma::read_filters::DateTimeFilter::Gte(
                value,
            ))
        }
        pub fn not(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Created(_prisma::read_filters::DateTimeFilter::Not(
                value,
            ))
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Created(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("created")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Created(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("created")
            }
        }
    }
    pub mod updated {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(
            pub  Option<
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            >,
        );
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUpdated(value.0)
            }
        }
        pub fn set<T: From<Set>>(
            value: Option<
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::Updated(direction)
        }
        pub fn equals(
            value: Option<
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            >,
        ) -> WhereParam {
            WhereParam::Updated(
                _prisma::read_filters::DateTimeNullableFilter::Equals(value),
            )
        }
        pub fn in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            >,
        ) -> WhereParam {
            WhereParam::Updated(
                _prisma::read_filters::DateTimeNullableFilter::InVec(value),
            )
        }
        pub fn not_in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            >,
        ) -> WhereParam {
            WhereParam::Updated(
                _prisma::read_filters::DateTimeNullableFilter::NotInVec(value),
            )
        }
        pub fn lt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Updated(
                _prisma::read_filters::DateTimeNullableFilter::Lt(value),
            )
        }
        pub fn lte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Updated(
                _prisma::read_filters::DateTimeNullableFilter::Lte(value),
            )
        }
        pub fn gt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Updated(
                _prisma::read_filters::DateTimeNullableFilter::Gt(value),
            )
        }
        pub fn gte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Updated(
                _prisma::read_filters::DateTimeNullableFilter::Gte(value),
            )
        }
        pub fn not(
            value: Option<
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            >,
        ) -> WhereParam {
            WhereParam::Updated(
                _prisma::read_filters::DateTimeNullableFilter::Not(value),
            )
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Updated(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("updated")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Updated(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("updated")
            }
        }
    }
    pub mod accounts {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Fetch(pub account::ManyArgs);
        impl Fetch {
            pub fn with(
                mut self,
                params: impl Into<account::WithParam>,
            ) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: account::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: account::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Accounts(fetch.0)
            }
        }
        pub fn fetch(params: Vec<account::WhereParam>) -> Fetch {
            Fetch(account::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<account::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectAccounts(value.0)
            }
        }
        pub fn connect<T: From<Connect>>(
            params: Vec<account::UniqueWhereParam>,
        ) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<account::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectAccounts(params)
        }
        pub fn set(params: Vec<account::UniqueWhereParam>) -> SetParam {
            SetParam::SetAccounts(params)
        }
        pub fn some(value: Vec<account::WhereParam>) -> WhereParam {
            WhereParam::AccountsSome(value)
        }
        pub fn every(value: Vec<account::WhereParam>) -> WhereParam {
            WhereParam::AccountsEvery(value)
        }
        pub fn none(value: Vec<account::WhereParam>) -> WhereParam {
            WhereParam::AccountsNone(value)
        }
        pub enum Include {
            Select(account::ManyArgs, Vec<account::SelectParam>),
            Include(account::ManyArgs, Vec<account::IncludeParam>),
            Fetch(account::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Accounts(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < account :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < account :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(
                    "accounts", None, args, selections,
                )
            }
            pub fn select(
                args: account::ManyArgs,
                nested_selections: Vec<account::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: account::ManyArgs,
                nested_selections: Vec<account::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(account::ManyArgs, Vec<account::SelectParam>),
            Include(account::ManyArgs, Vec<account::IncludeParam>),
            Fetch(account::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Accounts(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < account :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(
                    "accounts", None, args, selections,
                )
            }
            pub fn select(
                args: account::ManyArgs,
                nested_selections: Vec<account::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: account::ManyArgs,
                nested_selections: Vec<account::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn create(
        username: String,
        email: String,
        first_name: String,
        last_name: String,
        _params: Vec<SetParam>,
    ) -> (String, String, String, String, Vec<SetParam>) {
        (username, email, first_name, last_name, _params)
    }
    pub fn create_unchecked(
        username: String,
        email: String,
        first_name: String,
        last_name: String,
        _params: Vec<SetParam>,
    ) -> (String, String, String, String, Vec<SetParam>) {
        (username, email, first_name, last_name, _params)
    }
    #[macro_export]
    macro_rules ! _select_user { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: user :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = $ crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([$ crate :: prisma :: user :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: user :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = $ crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([$ crate :: prisma :: user :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , username , email , first_name , last_name , is_active , created , updated , accounts } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: user :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: user :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: user :: select ! (@ field_serde_name ; $ field) , ", ") , + ,)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: user :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "username" , "email" , "first_name" , "last_name" , "is_active" , "created" , "updated" , "accounts"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: user :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; username) => { String } ; (@ field_type ; email) => { String } ; (@ field_type ; first_name) => { String } ; (@ field_type ; last_name) => { String } ; (@ field_type ; is_active) => { bool } ; (@ field_type ; created) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; updated) => { Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > } ; (@ field_type ; accounts : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < accounts :: Data > } ; (@ field_type ; accounts) => { Vec < crate :: prisma :: account :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "User" , available relations are "id, username, email, first_name, last_name, is_active, created, updated, accounts")) } ; (@ field_module ; accounts : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: account :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: id :: Select) } ; (@ selection_field_to_selection_param ; username) => { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: username :: Select) } ; (@ selection_field_to_selection_param ; email) => { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: email :: Select) } ; (@ selection_field_to_selection_param ; first_name) => { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: first_name :: Select) } ; (@ selection_field_to_selection_param ; last_name) => { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: last_name :: Select) } ; (@ selection_field_to_selection_param ; is_active) => { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: is_active :: Select) } ; (@ selection_field_to_selection_param ; created) => { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: created :: Select) } ; (@ selection_field_to_selection_param ; updated) => { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: updated :: Select) } ; (@ selection_field_to_selection_param ; accounts $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: accounts :: Select :: $ selection_mode ($ crate :: prisma :: account :: ManyArgs :: new ($ crate :: prisma :: account :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: account :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; accounts $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: accounts :: Select :: Fetch ($ crate :: prisma :: account :: ManyArgs :: new ($ crate :: prisma :: account :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: user :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; username) => { "username" } ; (@ field_serde_name ; email) => { "email" } ; (@ field_serde_name ; first_name) => { "first_name" } ; (@ field_serde_name ; last_name) => { "last_name" } ; (@ field_serde_name ; is_active) => { "is_active" } ; (@ field_serde_name ; created) => { "created" } ; (@ field_serde_name ; updated) => { "updated" } ; (@ field_serde_name ; accounts) => { "accounts" } ; }
    pub use _select_user as select;
    pub enum SelectParam {
        Id(id::Select),
        Username(username::Select),
        Email(email::Select),
        FirstName(first_name::Select),
        LastName(last_name::Select),
        IsActive(is_active::Select),
        Created(created::Select),
        Updated(updated::Select),
        Accounts(accounts::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Username(data) => data.to_selection(),
                Self::Email(data) => data.to_selection(),
                Self::FirstName(data) => data.to_selection(),
                Self::LastName(data) => data.to_selection(),
                Self::IsActive(data) => data.to_selection(),
                Self::Created(data) => data.to_selection(),
                Self::Updated(data) => data.to_selection(),
                Self::Accounts(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_user { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: user :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = $ crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([$ crate :: prisma :: user :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < $ crate :: prisma :: user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: user :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = $ crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([$ crate :: prisma :: user :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < $ crate :: prisma :: user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { accounts } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub username : String , pub email : String , pub first_name : String , pub last_name : String , pub is_active : bool , pub created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub updated : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , $ (pub $ field : $ crate :: prisma :: user :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (username) , stringify ! (email) , stringify ! (first_name) , stringify ! (last_name) , stringify ! (is_active) , stringify ! (created) , stringify ! (updated)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; username) , & self . username) ? ; state . serialize_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; email) , & self . email) ? ; state . serialize_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; first_name) , & self . first_name) ? ; state . serialize_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; last_name) , & self . last_name) ? ; state . serialize_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; is_active) , & self . is_active) ? ; state . serialize_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; created) , & self . created) ? ; state . serialize_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; updated) , & self . updated) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , username , email , first_name , last_name , is_active , created , updated } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: user :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: user :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: user :: include ! (@ field_serde_name ; username) , ", " , $ crate :: prisma :: user :: include ! (@ field_serde_name ; email) , ", " , $ crate :: prisma :: user :: include ! (@ field_serde_name ; first_name) , ", " , $ crate :: prisma :: user :: include ! (@ field_serde_name ; last_name) , ", " , $ crate :: prisma :: user :: include ! (@ field_serde_name ; is_active) , ", " , $ crate :: prisma :: user :: include ! (@ field_serde_name ; created) , ", " , $ crate :: prisma :: user :: include ! (@ field_serde_name ; updated) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: user :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: user :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: user :: include ! (@ field_serde_name ; username) => Ok (Field :: username) , $ crate :: prisma :: user :: include ! (@ field_serde_name ; email) => Ok (Field :: email) , $ crate :: prisma :: user :: include ! (@ field_serde_name ; first_name) => Ok (Field :: first_name) , $ crate :: prisma :: user :: include ! (@ field_serde_name ; last_name) => Ok (Field :: last_name) , $ crate :: prisma :: user :: include ! (@ field_serde_name ; is_active) => Ok (Field :: is_active) , $ crate :: prisma :: user :: include ! (@ field_serde_name ; created) => Ok (Field :: created) , $ crate :: prisma :: user :: include ! (@ field_serde_name ; updated) => Ok (Field :: updated) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut username = None ; let mut email = None ; let mut first_name = None ; let mut last_name = None ; let mut is_active = None ; let mut created = None ; let mut updated = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: username => { if username . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; username))) ; } username = Some (map . next_value () ?) ; } Field :: email => { if email . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; email))) ; } email = Some (map . next_value () ?) ; } Field :: first_name => { if first_name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; first_name))) ; } first_name = Some (map . next_value () ?) ; } Field :: last_name => { if last_name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; last_name))) ; } last_name = Some (map . next_value () ?) ; } Field :: is_active => { if is_active . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; is_active))) ; } is_active = Some (map . next_value () ?) ; } Field :: created => { if created . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; created))) ; } created = Some (map . next_value () ?) ; } Field :: updated => { if updated . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; updated))) ; } updated = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; id))) ? ; let username = username . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; username))) ? ; let email = email . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; email))) ? ; let first_name = first_name . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; first_name))) ? ; let last_name = last_name . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; last_name))) ? ; let is_active = is_active . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; is_active))) ? ; let created = created . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; created))) ? ; let updated = updated . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; updated))) ? ; Ok (Data { id , username , email , first_name , last_name , is_active , created , updated , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "username" , "email" , "first_name" , "last_name" , "is_active" , "created" , "updated" , "accounts"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: user :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; accounts : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < accounts :: Data > } ; (@ field_type ; accounts) => { Vec < crate :: prisma :: account :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "User" , available relations are "accounts")) } ; (@ field_module ; accounts : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: account :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; accounts $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: user :: IncludeParam > :: into ($ crate :: prisma :: user :: accounts :: Include :: $ selection_mode ($ crate :: prisma :: account :: ManyArgs :: new ($ crate :: prisma :: account :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: account :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; accounts $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: user :: IncludeParam > :: into ($ crate :: prisma :: user :: accounts :: Include :: Fetch ($ crate :: prisma :: account :: ManyArgs :: new ($ crate :: prisma :: account :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: user :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; username) => { "username" } ; (@ field_serde_name ; email) => { "email" } ; (@ field_serde_name ; first_name) => { "first_name" } ; (@ field_serde_name ; last_name) => { "last_name" } ; (@ field_serde_name ; is_active) => { "is_active" } ; (@ field_serde_name ; created) => { "created" } ; (@ field_serde_name ; updated) => { "updated" } ; (@ field_serde_name ; accounts) => { "accounts" } ; }
    pub use _include_user as include;
    pub enum IncludeParam {
        Id(id::Include),
        Username(username::Include),
        Email(email::Include),
        FirstName(first_name::Include),
        LastName(last_name::Include),
        IsActive(is_active::Include),
        Created(created::Include),
        Updated(updated::Include),
        Accounts(accounts::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Username(data) => data.to_selection(),
                Self::Email(data) => data.to_selection(),
                Self::FirstName(data) => data.to_selection(),
                Self::LastName(data) => data.to_selection(),
                Self::IsActive(data) => data.to_selection(),
                Self::Created(data) => data.to_selection(),
                Self::Updated(data) => data.to_selection(),
                Self::Accounts(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "username")]
        pub username: String,
        #[serde(rename = "email")]
        pub email: String,
        #[serde(rename = "first_name")]
        pub first_name: String,
        #[serde(rename = "last_name")]
        pub last_name: String,
        #[serde(rename = "is_active")]
        pub is_active: bool,
        #[serde(rename = "created")]
        pub created: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        #[serde(rename = "updated")]
        pub updated: Option<
            ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        >,
        #[serde(rename = "accounts")]
        pub accounts: Option<Vec<super::account::Data>>,
    }
    impl Data {
        pub fn accounts(
            &self,
        ) -> Result<
            &Vec<super::account::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.accounts.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(
                    accounts
                )),
            )
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Accounts(super::account::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Accounts(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: account :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        "accounts",
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetUsername(String),
        SetEmail(String),
        SetFirstName(String),
        SetLastName(String),
        SetIsActive(bool),
        SetCreated(
            ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ),
        SetUpdated(
            Option<
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            >,
        ),
        ConnectAccounts(Vec<super::account::UniqueWhereParam>),
        DisconnectAccounts(Vec<super::account::UniqueWhereParam>),
        SetAccounts(Vec<super::account::UniqueWhereParam>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self { SetParam :: SetId (value) => ("id" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetUsername (value) => ("username" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetEmail (value) => ("email" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetFirstName (value) => ("first_name" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetLastName (value) => ("last_name" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetIsActive (value) => ("is_active" . to_string () , :: prisma_client_rust :: PrismaValue :: Boolean (value)) , SetParam :: SetCreated (value) => ("created" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value)) , SetParam :: SetUpdated (value) => ("updated" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: DateTime (value)) . unwrap_or_else (|| :: prisma_client_rust :: PrismaValue :: Null)) , SetParam :: ConnectAccounts (where_params) => ("accounts" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: account :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , SetParam :: DisconnectAccounts (where_params) => ("accounts" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("disconnect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: account :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , SetParam :: SetAccounts (where_params) => ("accounts" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("set" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: account :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Username(::prisma_client_rust::Direction),
        Email(::prisma_client_rust::Direction),
        FirstName(::prisma_client_rust::Direction),
        LastName(::prisma_client_rust::Direction),
        IsActive(::prisma_client_rust::Direction),
        Created(::prisma_client_rust::Direction),
        Updated(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
                Self::Username(direction) => (
                    "username".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
                Self::Email(direction) => (
                    "email".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
                Self::FirstName(direction) => (
                    "first_name".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
                Self::LastName(direction) => (
                    "last_name".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
                Self::IsActive(direction) => (
                    "is_active".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
                Self::Created(direction) => (
                    "created".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
                Self::Updated(direction) => (
                    "updated".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::StringFilter),
        Username(_prisma::read_filters::StringFilter),
        Email(_prisma::read_filters::StringFilter),
        FirstName(_prisma::read_filters::StringFilter),
        LastName(_prisma::read_filters::StringFilter),
        IsActive(_prisma::read_filters::BoolFilter),
        Created(_prisma::read_filters::DateTimeFilter),
        Updated(_prisma::read_filters::DateTimeNullableFilter),
        AccountsSome(Vec<super::account::WhereParam>),
        AccountsEvery(Vec<super::account::WhereParam>),
        AccountsNone(Vec<super::account::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . map (| v | vec ! [v]) . map (:: prisma_client_rust :: PrismaValue :: Object) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Id (value) => ("id" , value . into ()) , Self :: Username (value) => ("username" , value . into ()) , Self :: Email (value) => ("email" , value . into ()) , Self :: FirstName (value) => ("first_name" , value . into ()) , Self :: LastName (value) => ("last_name" , value . into ()) , Self :: IsActive (value) => ("is_active" , value . into ()) , Self :: Created (value) => ("created" , value . into ()) , Self :: Updated (value) => ("updated" , value . into ()) , Self :: AccountsSome (where_params) => ("accounts" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("some" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: AccountsEvery (where_params) => ("accounts" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("every" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: AccountsNone (where_params) => ("accounts" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("none" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) } ;
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        EmailEquals(String),
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::EmailEquals(value) => Self::Email(
                    _prisma::read_filters::StringFilter::Equals(value),
                ),
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::StringFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = "User";
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            [
                "id",
                "username",
                "email",
                "first_name",
                "last_name",
                "is_active",
                "created",
                "updated",
            ]
            .into_iter()
            .map(::prisma_client_rust::sel)
            .collect()
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            username: String,
            email: String,
            first_name: String,
            last_name: String,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(username::set(username));
            _params.push(email::set(email));
            _params.push(first_name::set(first_name));
            _params.push(last_name::set(last_name));
            Create::new(self.client, _params)
        }
        pub fn create_many(
            self,
            data: Vec<(String, String, String, String, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(username, email, first_name, last_name, mut _params)| {
                    _params.push(username::set(username));
                    _params.push(email::set(email));
                    _params.push(first_name::set(first_name));
                    _params.push(last_name::set(last_name));
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(
            self,
            _where: UniqueWhereParam,
            _params: Vec<SetParam>,
        ) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (username, email, first_name, last_name, mut _params): (
                String,
                String,
                String,
                String,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(username::set(username));
            _params.push(email::set(email));
            _params.push(first_name::set(first_name));
            _params.push(last_name::set(last_name));
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod role {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::StartsWith(
                value,
            ))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("id")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("id")
            }
        }
    }
    pub mod name {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetName(value.0)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Equals(value))
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::NotInVec(
                value,
            ))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Contains(
                value,
            ))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::StartsWith(
                value,
            ))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::EndsWith(
                value,
            ))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Name(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("name")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Name(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("name")
            }
        }
    }
    pub mod description {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetDescription(value.0)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::Description(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Description(
                _prisma::read_filters::StringFilter::Equals(value),
            )
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Description(_prisma::read_filters::StringFilter::InVec(
                value,
            ))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Description(
                _prisma::read_filters::StringFilter::NotInVec(value),
            )
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Description(_prisma::read_filters::StringFilter::Lt(
                value,
            ))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Description(_prisma::read_filters::StringFilter::Lte(
                value,
            ))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Description(_prisma::read_filters::StringFilter::Gt(
                value,
            ))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Description(_prisma::read_filters::StringFilter::Gte(
                value,
            ))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Description(
                _prisma::read_filters::StringFilter::Contains(value),
            )
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Description(
                _prisma::read_filters::StringFilter::StartsWith(value),
            )
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Description(
                _prisma::read_filters::StringFilter::EndsWith(value),
            )
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Description(_prisma::read_filters::StringFilter::Mode(
                value,
            ))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Description(_prisma::read_filters::StringFilter::Not(
                value,
            ))
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Description(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("description")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Description(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("description")
            }
        }
    }
    pub mod user_roles {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Fetch(pub guest_role::ManyArgs);
        impl Fetch {
            pub fn with(
                mut self,
                params: impl Into<guest_role::WithParam>,
            ) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: guest_role::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(
                mut self,
                value: guest_role::UniqueWhereParam,
            ) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::UserRoles(fetch.0)
            }
        }
        pub fn fetch(params: Vec<guest_role::WhereParam>) -> Fetch {
            Fetch(guest_role::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<guest_role::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectUserRoles(value.0)
            }
        }
        pub fn connect<T: From<Connect>>(
            params: Vec<guest_role::UniqueWhereParam>,
        ) -> T {
            Connect(params).into()
        }
        pub fn disconnect(
            params: Vec<guest_role::UniqueWhereParam>,
        ) -> SetParam {
            SetParam::DisconnectUserRoles(params)
        }
        pub fn set(params: Vec<guest_role::UniqueWhereParam>) -> SetParam {
            SetParam::SetUserRoles(params)
        }
        pub fn some(value: Vec<guest_role::WhereParam>) -> WhereParam {
            WhereParam::UserRolesSome(value)
        }
        pub fn every(value: Vec<guest_role::WhereParam>) -> WhereParam {
            WhereParam::UserRolesEvery(value)
        }
        pub fn none(value: Vec<guest_role::WhereParam>) -> WhereParam {
            WhereParam::UserRolesNone(value)
        }
        pub enum Include {
            Select(guest_role::ManyArgs, Vec<guest_role::SelectParam>),
            Include(guest_role::ManyArgs, Vec<guest_role::IncludeParam>),
            Fetch(guest_role::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UserRoles(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < guest_role :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < guest_role :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(
                    "user_roles",
                    None,
                    args,
                    selections,
                )
            }
            pub fn select(
                args: guest_role::ManyArgs,
                nested_selections: Vec<guest_role::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: guest_role::ManyArgs,
                nested_selections: Vec<guest_role::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(guest_role::ManyArgs, Vec<guest_role::SelectParam>),
            Include(guest_role::ManyArgs, Vec<guest_role::IncludeParam>),
            Fetch(guest_role::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UserRoles(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < guest_role :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(
                    "user_roles",
                    None,
                    args,
                    selections,
                )
            }
            pub fn select(
                args: guest_role::ManyArgs,
                nested_selections: Vec<guest_role::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: guest_role::ManyArgs,
                nested_selections: Vec<guest_role::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn create(
        name: String,
        description: String,
        _params: Vec<SetParam>,
    ) -> (String, String, Vec<SetParam>) {
        (name, description, _params)
    }
    pub fn create_unchecked(
        name: String,
        description: String,
        _params: Vec<SetParam>,
    ) -> (String, String, Vec<SetParam>) {
        (name, description, _params)
    }
    #[macro_export]
    macro_rules ! _select_role { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: role :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = $ crate :: prisma :: role :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([$ crate :: prisma :: role :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: role :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = $ crate :: prisma :: role :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([$ crate :: prisma :: role :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , name , description , user_roles } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: role :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: role :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: role :: select ! (@ field_serde_name ; $ field) , ", ") , + ,)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: role :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: role :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: role :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "description" , "user_roles"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: role :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; name) => { String } ; (@ field_type ; description) => { String } ; (@ field_type ; user_roles : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < user_roles :: Data > } ; (@ field_type ; user_roles) => { Vec < crate :: prisma :: guest_role :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Role" , available relations are "id, name, description, user_roles")) } ; (@ field_module ; user_roles : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: guest_role :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: role :: SelectParam > :: into ($ crate :: prisma :: role :: id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < $ crate :: prisma :: role :: SelectParam > :: into ($ crate :: prisma :: role :: name :: Select) } ; (@ selection_field_to_selection_param ; description) => { Into :: < $ crate :: prisma :: role :: SelectParam > :: into ($ crate :: prisma :: role :: description :: Select) } ; (@ selection_field_to_selection_param ; user_roles $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: role :: SelectParam > :: into ($ crate :: prisma :: role :: user_roles :: Select :: $ selection_mode ($ crate :: prisma :: guest_role :: ManyArgs :: new ($ crate :: prisma :: guest_role :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: guest_role :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; user_roles $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: role :: SelectParam > :: into ($ crate :: prisma :: role :: user_roles :: Select :: Fetch ($ crate :: prisma :: guest_role :: ManyArgs :: new ($ crate :: prisma :: guest_role :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: role :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; description) => { "description" } ; (@ field_serde_name ; user_roles) => { "user_roles" } ; }
    pub use _select_role as select;
    pub enum SelectParam {
        Id(id::Select),
        Name(name::Select),
        Description(description::Select),
        UserRoles(user_roles::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Description(data) => data.to_selection(),
                Self::UserRoles(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_role { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: role :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = $ crate :: prisma :: role :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([$ crate :: prisma :: role :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < $ crate :: prisma :: role :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: role :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = $ crate :: prisma :: role :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([$ crate :: prisma :: role :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < $ crate :: prisma :: role :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { user_roles } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub name : String , pub description : String , $ (pub $ field : $ crate :: prisma :: role :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (name) , stringify ! (description)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: role :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: role :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: role :: include ! (@ field_serde_name ; name) , & self . name) ? ; state . serialize_field ($ crate :: prisma :: role :: include ! (@ field_serde_name ; description) , & self . description) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , name , description } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: role :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: role :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: role :: include ! (@ field_serde_name ; name) , ", " , $ crate :: prisma :: role :: include ! (@ field_serde_name ; description) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: role :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: role :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: role :: include ! (@ field_serde_name ; name) => Ok (Field :: name) , $ crate :: prisma :: role :: include ! (@ field_serde_name ; description) => Ok (Field :: description) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut name = None ; let mut description = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: role :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: role :: include ! (@ field_serde_name ; name))) ; } name = Some (map . next_value () ?) ; } Field :: description => { if description . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: role :: include ! (@ field_serde_name ; description))) ; } description = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: role :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: role :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: role :: include ! (@ field_serde_name ; id))) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: role :: include ! (@ field_serde_name ; name))) ? ; let description = description . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: role :: include ! (@ field_serde_name ; description))) ? ; Ok (Data { id , name , description , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "description" , "user_roles"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: role :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; user_roles : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < user_roles :: Data > } ; (@ field_type ; user_roles) => { Vec < crate :: prisma :: guest_role :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Role" , available relations are "user_roles")) } ; (@ field_module ; user_roles : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: guest_role :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; user_roles $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: role :: IncludeParam > :: into ($ crate :: prisma :: role :: user_roles :: Include :: $ selection_mode ($ crate :: prisma :: guest_role :: ManyArgs :: new ($ crate :: prisma :: guest_role :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: guest_role :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; user_roles $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: role :: IncludeParam > :: into ($ crate :: prisma :: role :: user_roles :: Include :: Fetch ($ crate :: prisma :: guest_role :: ManyArgs :: new ($ crate :: prisma :: guest_role :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: role :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; description) => { "description" } ; (@ field_serde_name ; user_roles) => { "user_roles" } ; }
    pub use _include_role as include;
    pub enum IncludeParam {
        Id(id::Include),
        Name(name::Include),
        Description(description::Include),
        UserRoles(user_roles::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Description(data) => data.to_selection(),
                Self::UserRoles(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "description")]
        pub description: String,
        #[serde(rename = "user_roles")]
        pub user_roles: Option<Vec<super::guest_role::Data>>,
    }
    impl Data {
        pub fn user_roles(
            &self,
        ) -> Result<
            &Vec<super::guest_role::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.user_roles.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(
                    user_roles
                )),
            )
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        UserRoles(super::guest_role::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::UserRoles(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: guest_role :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        "user_roles",
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetName(String),
        SetDescription(String),
        ConnectUserRoles(Vec<super::guest_role::UniqueWhereParam>),
        DisconnectUserRoles(Vec<super::guest_role::UniqueWhereParam>),
        SetUserRoles(Vec<super::guest_role::UniqueWhereParam>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self { SetParam :: SetId (value) => ("id" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetName (value) => ("name" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetDescription (value) => ("description" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: ConnectUserRoles (where_params) => ("user_roles" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: guest_role :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , SetParam :: DisconnectUserRoles (where_params) => ("user_roles" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("disconnect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: guest_role :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , SetParam :: SetUserRoles (where_params) => ("user_roles" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("set" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: guest_role :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Name(::prisma_client_rust::Direction),
        Description(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
                Self::Name(direction) => (
                    "name".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
                Self::Description(direction) => (
                    "description".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::StringFilter),
        Name(_prisma::read_filters::StringFilter),
        Description(_prisma::read_filters::StringFilter),
        UserRolesSome(Vec<super::guest_role::WhereParam>),
        UserRolesEvery(Vec<super::guest_role::WhereParam>),
        UserRolesNone(Vec<super::guest_role::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . map (| v | vec ! [v]) . map (:: prisma_client_rust :: PrismaValue :: Object) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Id (value) => ("id" , value . into ()) , Self :: Name (value) => ("name" , value . into ()) , Self :: Description (value) => ("description" , value . into ()) , Self :: UserRolesSome (where_params) => ("user_roles" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("some" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: UserRolesEvery (where_params) => ("user_roles" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("every" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: UserRolesNone (where_params) => ("user_roles" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("none" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) } ;
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::StringFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = "Role";
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            ["id", "name", "description"]
                .into_iter()
                .map(::prisma_client_rust::sel)
                .collect()
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            name: String,
            description: String,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(name::set(name));
            _params.push(description::set(description));
            Create::new(self.client, _params)
        }
        pub fn create_many(
            self,
            data: Vec<(String, String, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(name, description, mut _params)| {
                    _params.push(name::set(name));
                    _params.push(description::set(description));
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(
            self,
            _where: UniqueWhereParam,
            _params: Vec<SetParam>,
        ) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (name, description, mut _params): (String, String, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(name::set(name));
            _params.push(description::set(description));
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod guest_role {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::StartsWith(
                value,
            ))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("id")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("id")
            }
        }
    }
    pub mod name {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetName(value.0)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::NameEquals(value).into()
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::NotInVec(
                value,
            ))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Contains(
                value,
            ))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::StartsWith(
                value,
            ))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::EndsWith(
                value,
            ))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Name(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("name")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Name(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("name")
            }
        }
    }
    pub mod description {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetDescription(value.0)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::Description(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::Description(
                _prisma::read_filters::StringNullableFilter::Equals(value),
            )
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Description(
                _prisma::read_filters::StringNullableFilter::InVec(value),
            )
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Description(
                _prisma::read_filters::StringNullableFilter::NotInVec(value),
            )
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Description(
                _prisma::read_filters::StringNullableFilter::Lt(value),
            )
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Description(
                _prisma::read_filters::StringNullableFilter::Lte(value),
            )
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Description(
                _prisma::read_filters::StringNullableFilter::Gt(value),
            )
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Description(
                _prisma::read_filters::StringNullableFilter::Gte(value),
            )
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Description(
                _prisma::read_filters::StringNullableFilter::Contains(value),
            )
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Description(
                _prisma::read_filters::StringNullableFilter::StartsWith(value),
            )
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Description(
                _prisma::read_filters::StringNullableFilter::EndsWith(value),
            )
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Description(
                _prisma::read_filters::StringNullableFilter::Mode(value),
            )
        }
        pub fn not(value: Option<String>) -> WhereParam {
            WhereParam::Description(
                _prisma::read_filters::StringNullableFilter::Not(value),
            )
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Description(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("description")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Description(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("description")
            }
        }
    }
    pub mod role {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Fetch(pub role::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<role::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Role(fetch.0)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(role::UniqueArgs::new())
        }
        pub struct Connect(role::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectRole(value.0)
            }
        }
        pub fn connect<T: From<Connect>>(value: role::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<role::WhereParam>) -> WhereParam {
            WhereParam::RoleIs(value)
        }
        pub fn is_not(value: Vec<role::WhereParam>) -> WhereParam {
            WhereParam::RoleIsNot(value)
        }
        pub enum Include {
            Select(Vec<role::SelectParam>),
            Include(Vec<role::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Role(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = < role :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < role :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new(
                    "role",
                    None,
                    [],
                    selections,
                )
            }
            pub fn select(nested_selections: Vec<role::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<role::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<role::SelectParam>),
            Include(Vec<role::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Role(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < role :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new(
                    "role",
                    None,
                    [],
                    selections,
                )
            }
            pub fn select(nested_selections: Vec<role::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<role::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod role_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetRoleId(value.0)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::RoleId(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::RoleId(_prisma::read_filters::StringFilter::Equals(
                value,
            ))
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::RoleId(_prisma::read_filters::StringFilter::InVec(
                value,
            ))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::RoleId(_prisma::read_filters::StringFilter::NotInVec(
                value,
            ))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::RoleId(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::RoleId(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::RoleId(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::RoleId(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::RoleId(_prisma::read_filters::StringFilter::Contains(
                value,
            ))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::RoleId(_prisma::read_filters::StringFilter::StartsWith(
                value,
            ))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::RoleId(_prisma::read_filters::StringFilter::EndsWith(
                value,
            ))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::RoleId(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::RoleId(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::RoleId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("role_id")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::RoleId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("role_id")
            }
        }
    }
    pub mod permissions {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(pub Vec<i32>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetPermissions(value.0)
            }
        }
        pub fn set<T: From<Set>>(value: Vec<i32>) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::Permissions(direction)
        }
        pub fn push(value: Vec<i32>) -> SetParam {
            SetParam::PushPermissions(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Permissions(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("permissions")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Permissions(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("permissions")
            }
        }
    }
    pub mod guest_users {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Fetch(pub guest_user::ManyArgs);
        impl Fetch {
            pub fn with(
                mut self,
                params: impl Into<guest_user::WithParam>,
            ) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: guest_user::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(
                mut self,
                value: guest_user::UniqueWhereParam,
            ) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::GuestUsers(fetch.0)
            }
        }
        pub fn fetch(params: Vec<guest_user::WhereParam>) -> Fetch {
            Fetch(guest_user::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<guest_user::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectGuestUsers(value.0)
            }
        }
        pub fn connect<T: From<Connect>>(
            params: Vec<guest_user::UniqueWhereParam>,
        ) -> T {
            Connect(params).into()
        }
        pub fn disconnect(
            params: Vec<guest_user::UniqueWhereParam>,
        ) -> SetParam {
            SetParam::DisconnectGuestUsers(params)
        }
        pub fn set(params: Vec<guest_user::UniqueWhereParam>) -> SetParam {
            SetParam::SetGuestUsers(params)
        }
        pub fn some(value: Vec<guest_user::WhereParam>) -> WhereParam {
            WhereParam::GuestUsersSome(value)
        }
        pub fn every(value: Vec<guest_user::WhereParam>) -> WhereParam {
            WhereParam::GuestUsersEvery(value)
        }
        pub fn none(value: Vec<guest_user::WhereParam>) -> WhereParam {
            WhereParam::GuestUsersNone(value)
        }
        pub enum Include {
            Select(guest_user::ManyArgs, Vec<guest_user::SelectParam>),
            Include(guest_user::ManyArgs, Vec<guest_user::IncludeParam>),
            Fetch(guest_user::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::GuestUsers(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < guest_user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < guest_user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(
                    "guest_users",
                    None,
                    args,
                    selections,
                )
            }
            pub fn select(
                args: guest_user::ManyArgs,
                nested_selections: Vec<guest_user::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: guest_user::ManyArgs,
                nested_selections: Vec<guest_user::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(guest_user::ManyArgs, Vec<guest_user::SelectParam>),
            Include(guest_user::ManyArgs, Vec<guest_user::IncludeParam>),
            Fetch(guest_user::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::GuestUsers(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < guest_user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(
                    "guest_users",
                    None,
                    args,
                    selections,
                )
            }
            pub fn select(
                args: guest_user::ManyArgs,
                nested_selections: Vec<guest_user::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: guest_user::ManyArgs,
                nested_selections: Vec<guest_user::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn create(
        name: String,
        role: super::role::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (String, super::role::UniqueWhereParam, Vec<SetParam>) {
        (name, role, _params)
    }
    pub fn create_unchecked(
        name: String,
        role_id: String,
        _params: Vec<SetParam>,
    ) -> (String, String, Vec<SetParam>) {
        (name, role_id, _params)
    }
    #[macro_export]
    macro_rules ! _select_guest_role { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: guest_role :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = $ crate :: prisma :: guest_role :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([$ crate :: prisma :: guest_role :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: guest_role :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = $ crate :: prisma :: guest_role :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([$ crate :: prisma :: guest_role :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , name , description , role , role_id , permissions , guest_users } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: guest_role :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: guest_role :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: guest_role :: select ! (@ field_serde_name ; $ field) , ", ") , + ,)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: guest_role :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guest_role :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guest_role :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "description" , "role" , "role_id" , "permissions" , "guest_users"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: guest_role :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; name) => { String } ; (@ field_type ; description) => { Option < String > } ; (@ field_type ; role : $ selection_mode : ident { $ ($ selections : tt) + }) => { role :: Data } ; (@ field_type ; role) => { crate :: prisma :: role :: Data } ; (@ field_type ; role_id) => { String } ; (@ field_type ; permissions) => { Vec < i32 > } ; (@ field_type ; guest_users : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < guest_users :: Data > } ; (@ field_type ; guest_users) => { Vec < crate :: prisma :: guest_user :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "GuestRole" , available relations are "id, name, description, role, role_id, permissions, guest_users")) } ; (@ field_module ; role : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: role :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; guest_users : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: guest_user :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: guest_role :: SelectParam > :: into ($ crate :: prisma :: guest_role :: id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < $ crate :: prisma :: guest_role :: SelectParam > :: into ($ crate :: prisma :: guest_role :: name :: Select) } ; (@ selection_field_to_selection_param ; description) => { Into :: < $ crate :: prisma :: guest_role :: SelectParam > :: into ($ crate :: prisma :: guest_role :: description :: Select) } ; (@ selection_field_to_selection_param ; role $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: guest_role :: SelectParam > :: into ($ crate :: prisma :: guest_role :: role :: Select :: $ selection_mode ($ crate :: prisma :: role :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; role $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: guest_role :: SelectParam > :: into ($ crate :: prisma :: guest_role :: role :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; role_id) => { Into :: < $ crate :: prisma :: guest_role :: SelectParam > :: into ($ crate :: prisma :: guest_role :: role_id :: Select) } ; (@ selection_field_to_selection_param ; permissions) => { Into :: < $ crate :: prisma :: guest_role :: SelectParam > :: into ($ crate :: prisma :: guest_role :: permissions :: Select) } ; (@ selection_field_to_selection_param ; guest_users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: guest_role :: SelectParam > :: into ($ crate :: prisma :: guest_role :: guest_users :: Select :: $ selection_mode ($ crate :: prisma :: guest_user :: ManyArgs :: new ($ crate :: prisma :: guest_user :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: guest_user :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; guest_users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: guest_role :: SelectParam > :: into ($ crate :: prisma :: guest_role :: guest_users :: Select :: Fetch ($ crate :: prisma :: guest_user :: ManyArgs :: new ($ crate :: prisma :: guest_user :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: guest_role :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; description) => { "description" } ; (@ field_serde_name ; role) => { "role" } ; (@ field_serde_name ; role_id) => { "role_id" } ; (@ field_serde_name ; permissions) => { "permissions" } ; (@ field_serde_name ; guest_users) => { "guest_users" } ; }
    pub use _select_guest_role as select;
    pub enum SelectParam {
        Id(id::Select),
        Name(name::Select),
        Description(description::Select),
        Role(role::Select),
        RoleId(role_id::Select),
        Permissions(permissions::Select),
        GuestUsers(guest_users::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Description(data) => data.to_selection(),
                Self::Role(data) => data.to_selection(),
                Self::RoleId(data) => data.to_selection(),
                Self::Permissions(data) => data.to_selection(),
                Self::GuestUsers(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_guest_role { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: guest_role :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = $ crate :: prisma :: guest_role :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([$ crate :: prisma :: guest_role :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < $ crate :: prisma :: guest_role :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: guest_role :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = $ crate :: prisma :: guest_role :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([$ crate :: prisma :: guest_role :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < $ crate :: prisma :: guest_role :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { role , guest_users } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub name : String , pub description : Option < String > , pub role_id : String , pub permissions : Vec < i32 > , $ (pub $ field : $ crate :: prisma :: guest_role :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (name) , stringify ! (description) , stringify ! (role_id) , stringify ! (permissions)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: guest_role :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: guest_role :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: guest_role :: include ! (@ field_serde_name ; name) , & self . name) ? ; state . serialize_field ($ crate :: prisma :: guest_role :: include ! (@ field_serde_name ; description) , & self . description) ? ; state . serialize_field ($ crate :: prisma :: guest_role :: include ! (@ field_serde_name ; role_id) , & self . role_id) ? ; state . serialize_field ($ crate :: prisma :: guest_role :: include ! (@ field_serde_name ; permissions) , & self . permissions) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , name , description , role_id , permissions } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: guest_role :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: guest_role :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: guest_role :: include ! (@ field_serde_name ; name) , ", " , $ crate :: prisma :: guest_role :: include ! (@ field_serde_name ; description) , ", " , $ crate :: prisma :: guest_role :: include ! (@ field_serde_name ; role_id) , ", " , $ crate :: prisma :: guest_role :: include ! (@ field_serde_name ; permissions) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: guest_role :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: guest_role :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: guest_role :: include ! (@ field_serde_name ; name) => Ok (Field :: name) , $ crate :: prisma :: guest_role :: include ! (@ field_serde_name ; description) => Ok (Field :: description) , $ crate :: prisma :: guest_role :: include ! (@ field_serde_name ; role_id) => Ok (Field :: role_id) , $ crate :: prisma :: guest_role :: include ! (@ field_serde_name ; permissions) => Ok (Field :: permissions) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut name = None ; let mut description = None ; let mut role_id = None ; let mut permissions = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guest_role :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guest_role :: include ! (@ field_serde_name ; name))) ; } name = Some (map . next_value () ?) ; } Field :: description => { if description . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guest_role :: include ! (@ field_serde_name ; description))) ; } description = Some (map . next_value () ?) ; } Field :: role_id => { if role_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guest_role :: include ! (@ field_serde_name ; role_id))) ; } role_id = Some (map . next_value () ?) ; } Field :: permissions => { if permissions . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guest_role :: include ! (@ field_serde_name ; permissions))) ; } permissions = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guest_role :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guest_role :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guest_role :: include ! (@ field_serde_name ; id))) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guest_role :: include ! (@ field_serde_name ; name))) ? ; let description = description . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guest_role :: include ! (@ field_serde_name ; description))) ? ; let role_id = role_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guest_role :: include ! (@ field_serde_name ; role_id))) ? ; let permissions = permissions . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guest_role :: include ! (@ field_serde_name ; permissions))) ? ; Ok (Data { id , name , description , role_id , permissions , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "description" , "role" , "role_id" , "permissions" , "guest_users"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: guest_role :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; role : $ selection_mode : ident { $ ($ selections : tt) + }) => { role :: Data } ; (@ field_type ; role) => { crate :: prisma :: role :: Data } ; (@ field_type ; guest_users : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < guest_users :: Data > } ; (@ field_type ; guest_users) => { Vec < crate :: prisma :: guest_user :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "GuestRole" , available relations are "role, guest_users")) } ; (@ field_module ; role : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: role :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; guest_users : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: guest_user :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; role $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: guest_role :: IncludeParam > :: into ($ crate :: prisma :: guest_role :: role :: Include :: $ selection_mode ($ crate :: prisma :: role :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; role $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: guest_role :: IncludeParam > :: into ($ crate :: prisma :: guest_role :: role :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; guest_users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: guest_role :: IncludeParam > :: into ($ crate :: prisma :: guest_role :: guest_users :: Include :: $ selection_mode ($ crate :: prisma :: guest_user :: ManyArgs :: new ($ crate :: prisma :: guest_user :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: guest_user :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; guest_users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: guest_role :: IncludeParam > :: into ($ crate :: prisma :: guest_role :: guest_users :: Include :: Fetch ($ crate :: prisma :: guest_user :: ManyArgs :: new ($ crate :: prisma :: guest_user :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: guest_role :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; description) => { "description" } ; (@ field_serde_name ; role) => { "role" } ; (@ field_serde_name ; role_id) => { "role_id" } ; (@ field_serde_name ; permissions) => { "permissions" } ; (@ field_serde_name ; guest_users) => { "guest_users" } ; }
    pub use _include_guest_role as include;
    pub enum IncludeParam {
        Id(id::Include),
        Name(name::Include),
        Description(description::Include),
        Role(role::Include),
        RoleId(role_id::Include),
        Permissions(permissions::Include),
        GuestUsers(guest_users::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Description(data) => data.to_selection(),
                Self::Role(data) => data.to_selection(),
                Self::RoleId(data) => data.to_selection(),
                Self::Permissions(data) => data.to_selection(),
                Self::GuestUsers(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "description")]
        pub description: Option<String>,
        #[serde(rename = "role")]
        pub role: Option<Box<super::role::Data>>,
        #[serde(rename = "role_id")]
        pub role_id: String,
        #[serde(rename = "permissions")]
        pub permissions: Vec<i32>,
        #[serde(rename = "guest_users")]
        pub guest_users: Option<Vec<super::guest_user::Data>>,
    }
    impl Data {
        pub fn role(
            &self,
        ) -> Result<
            &super::role::Data,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.role
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(role),
                ))
                .map(|v| v.as_ref())
        }
        pub fn guest_users(
            &self,
        ) -> Result<
            &Vec<super::guest_user::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.guest_users.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(
                    guest_users
                )),
            )
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Role(super::role::UniqueArgs),
        GuestUsers(super::guest_user::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Role(args) => {
                    let mut selections = < super :: role :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(
                        "role",
                        None,
                        [],
                        selections,
                    )
                }
                Self::GuestUsers(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: guest_user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        "guest_users",
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetName(String),
        SetDescription(Option<String>),
        ConnectRole(super::role::UniqueWhereParam),
        SetRoleId(String),
        SetPermissions(Vec<i32>),
        PushPermissions(Vec<i32>),
        ConnectGuestUsers(Vec<super::guest_user::UniqueWhereParam>),
        DisconnectGuestUsers(Vec<super::guest_user::UniqueWhereParam>),
        SetGuestUsers(Vec<super::guest_user::UniqueWhereParam>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self { SetParam :: SetId (value) => ("id" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetName (value) => ("name" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetDescription (value) => ("description" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: String (value)) . unwrap_or_else (|| :: prisma_client_rust :: PrismaValue :: Null)) , SetParam :: ConnectRole (where_param) => ("role" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: Object ([where_param] . into_iter () . map (Into :: < super :: role :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()))])) , SetParam :: SetRoleId (value) => ("role_id" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetPermissions (value) => ("permissions" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: Int (v as i64)) . collect ())) , SetParam :: PushPermissions (value) => ("permissions" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("push" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: Int (v as i64)) . collect ()))])) , SetParam :: ConnectGuestUsers (where_params) => ("guest_users" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: guest_user :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , SetParam :: DisconnectGuestUsers (where_params) => ("guest_users" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("disconnect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: guest_user :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , SetParam :: SetGuestUsers (where_params) => ("guest_users" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("set" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: guest_user :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Name(::prisma_client_rust::Direction),
        Description(::prisma_client_rust::Direction),
        RoleId(::prisma_client_rust::Direction),
        Permissions(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
                Self::Name(direction) => (
                    "name".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
                Self::Description(direction) => (
                    "description".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
                Self::RoleId(direction) => (
                    "role_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
                Self::Permissions(direction) => (
                    "permissions".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::StringFilter),
        Name(_prisma::read_filters::StringFilter),
        Description(_prisma::read_filters::StringNullableFilter),
        RoleIs(Vec<super::role::WhereParam>),
        RoleIsNot(Vec<super::role::WhereParam>),
        RoleId(_prisma::read_filters::StringFilter),
        GuestUsersSome(Vec<super::guest_user::WhereParam>),
        GuestUsersEvery(Vec<super::guest_user::WhereParam>),
        GuestUsersNone(Vec<super::guest_user::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . map (| v | vec ! [v]) . map (:: prisma_client_rust :: PrismaValue :: Object) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Id (value) => ("id" , value . into ()) , Self :: Name (value) => ("name" , value . into ()) , Self :: Description (value) => ("description" , value . into ()) , Self :: RoleIs (where_params) => ("role" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("is" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: RoleIsNot (where_params) => ("role" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("isNot" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: RoleId (value) => ("role_id" , value . into ()) , Self :: GuestUsersSome (where_params) => ("guest_users" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("some" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: GuestUsersEvery (where_params) => ("guest_users" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("every" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: GuestUsersNone (where_params) => ("guest_users" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("none" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) } ;
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        NameEquals(String),
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::NameEquals(value) => Self::Name(
                    _prisma::read_filters::StringFilter::Equals(value),
                ),
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::StringFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = "GuestRole";
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            ["id", "name", "description", "role_id", "permissions"]
                .into_iter()
                .map(::prisma_client_rust::sel)
                .collect()
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            name: String,
            role: super::role::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(name::set(name));
            _params.push(role::connect(role));
            Create::new(self.client, _params)
        }
        pub fn create_many(
            self,
            data: Vec<(String, String, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(name, role_id, mut _params)| {
                    _params.push(name::set(name));
                    _params.push(role_id::set(role_id));
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(
            self,
            _where: UniqueWhereParam,
            _params: Vec<SetParam>,
        ) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (name, role, mut _params): (
                String,
                super::role::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(name::set(name));
            _params.push(role::connect(role));
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod guest_user {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::StartsWith(
                value,
            ))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("id")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("id")
            }
        }
    }
    pub mod email {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetEmail(value.0)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::Email(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Email(_prisma::read_filters::StringFilter::Equals(
                value,
            ))
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Email(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Email(_prisma::read_filters::StringFilter::NotInVec(
                value,
            ))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Email(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Email(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Email(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Email(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Email(_prisma::read_filters::StringFilter::Contains(
                value,
            ))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Email(_prisma::read_filters::StringFilter::StartsWith(
                value,
            ))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Email(_prisma::read_filters::StringFilter::EndsWith(
                value,
            ))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Email(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Email(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Email(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("email")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Email(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("email")
            }
        }
    }
    pub mod guest_role {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Fetch(pub guest_role::UniqueArgs);
        impl Fetch {
            pub fn with(
                mut self,
                params: impl Into<guest_role::WithParam>,
            ) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::GuestRole(fetch.0)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(guest_role::UniqueArgs::new())
        }
        pub struct Connect(guest_role::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectGuestRole(value.0)
            }
        }
        pub fn connect<T: From<Connect>>(
            value: guest_role::UniqueWhereParam,
        ) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<guest_role::WhereParam>) -> WhereParam {
            WhereParam::GuestRoleIs(value)
        }
        pub fn is_not(value: Vec<guest_role::WhereParam>) -> WhereParam {
            WhereParam::GuestRoleIsNot(value)
        }
        pub enum Include {
            Select(Vec<guest_role::SelectParam>),
            Include(Vec<guest_role::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::GuestRole(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = < guest_role :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < guest_role :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new(
                    "guest_role",
                    None,
                    [],
                    selections,
                )
            }
            pub fn select(
                nested_selections: Vec<guest_role::SelectParam>,
            ) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(
                nested_selections: Vec<guest_role::IncludeParam>,
            ) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<guest_role::SelectParam>),
            Include(Vec<guest_role::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::GuestRole(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < guest_role :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new(
                    "guest_role",
                    None,
                    [],
                    selections,
                )
            }
            pub fn select(
                nested_selections: Vec<guest_role::SelectParam>,
            ) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(
                nested_selections: Vec<guest_role::IncludeParam>,
            ) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod guest_role_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetGuestRoleId(value.0)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::GuestRoleId(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::GuestRoleId(
                _prisma::read_filters::StringFilter::Equals(value),
            )
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::GuestRoleId(_prisma::read_filters::StringFilter::InVec(
                value,
            ))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::GuestRoleId(
                _prisma::read_filters::StringFilter::NotInVec(value),
            )
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::GuestRoleId(_prisma::read_filters::StringFilter::Lt(
                value,
            ))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::GuestRoleId(_prisma::read_filters::StringFilter::Lte(
                value,
            ))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::GuestRoleId(_prisma::read_filters::StringFilter::Gt(
                value,
            ))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::GuestRoleId(_prisma::read_filters::StringFilter::Gte(
                value,
            ))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::GuestRoleId(
                _prisma::read_filters::StringFilter::Contains(value),
            )
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::GuestRoleId(
                _prisma::read_filters::StringFilter::StartsWith(value),
            )
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::GuestRoleId(
                _prisma::read_filters::StringFilter::EndsWith(value),
            )
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::GuestRoleId(_prisma::read_filters::StringFilter::Mode(
                value,
            ))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::GuestRoleId(_prisma::read_filters::StringFilter::Not(
                value,
            ))
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::GuestRoleId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("guest_role_id")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::GuestRoleId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("guest_role_id")
            }
        }
    }
    pub mod created {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(
            pub  ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        );
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreated(value.0)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::Created(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Created(_prisma::read_filters::DateTimeFilter::Equals(
                value,
            ))
        }
        pub fn in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            >,
        ) -> WhereParam {
            WhereParam::Created(_prisma::read_filters::DateTimeFilter::InVec(
                value,
            ))
        }
        pub fn not_in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            >,
        ) -> WhereParam {
            WhereParam::Created(
                _prisma::read_filters::DateTimeFilter::NotInVec(value),
            )
        }
        pub fn lt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Created(_prisma::read_filters::DateTimeFilter::Lt(
                value,
            ))
        }
        pub fn lte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Created(_prisma::read_filters::DateTimeFilter::Lte(
                value,
            ))
        }
        pub fn gt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Created(_prisma::read_filters::DateTimeFilter::Gt(
                value,
            ))
        }
        pub fn gte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Created(_prisma::read_filters::DateTimeFilter::Gte(
                value,
            ))
        }
        pub fn not(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Created(_prisma::read_filters::DateTimeFilter::Not(
                value,
            ))
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Created(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("created")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Created(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("created")
            }
        }
    }
    pub mod updated {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(
            pub  Option<
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            >,
        );
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUpdated(value.0)
            }
        }
        pub fn set<T: From<Set>>(
            value: Option<
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::Updated(direction)
        }
        pub fn equals(
            value: Option<
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            >,
        ) -> WhereParam {
            WhereParam::Updated(
                _prisma::read_filters::DateTimeNullableFilter::Equals(value),
            )
        }
        pub fn in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            >,
        ) -> WhereParam {
            WhereParam::Updated(
                _prisma::read_filters::DateTimeNullableFilter::InVec(value),
            )
        }
        pub fn not_in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            >,
        ) -> WhereParam {
            WhereParam::Updated(
                _prisma::read_filters::DateTimeNullableFilter::NotInVec(value),
            )
        }
        pub fn lt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Updated(
                _prisma::read_filters::DateTimeNullableFilter::Lt(value),
            )
        }
        pub fn lte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Updated(
                _prisma::read_filters::DateTimeNullableFilter::Lte(value),
            )
        }
        pub fn gt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Updated(
                _prisma::read_filters::DateTimeNullableFilter::Gt(value),
            )
        }
        pub fn gte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Updated(
                _prisma::read_filters::DateTimeNullableFilter::Gte(value),
            )
        }
        pub fn not(
            value: Option<
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            >,
        ) -> WhereParam {
            WhereParam::Updated(
                _prisma::read_filters::DateTimeNullableFilter::Not(value),
            )
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Updated(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("updated")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Updated(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("updated")
            }
        }
    }
    pub mod accounts {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Fetch(pub guest_user_on_account::ManyArgs);
        impl Fetch {
            pub fn with(
                mut self,
                params: impl Into<guest_user_on_account::WithParam>,
            ) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(
                mut self,
                param: guest_user_on_account::OrderByParam,
            ) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(
                mut self,
                value: guest_user_on_account::UniqueWhereParam,
            ) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Accounts(fetch.0)
            }
        }
        pub fn fetch(params: Vec<guest_user_on_account::WhereParam>) -> Fetch {
            Fetch(guest_user_on_account::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<guest_user_on_account::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectAccounts(value.0)
            }
        }
        pub fn connect<T: From<Connect>>(
            params: Vec<guest_user_on_account::UniqueWhereParam>,
        ) -> T {
            Connect(params).into()
        }
        pub fn disconnect(
            params: Vec<guest_user_on_account::UniqueWhereParam>,
        ) -> SetParam {
            SetParam::DisconnectAccounts(params)
        }
        pub fn set(
            params: Vec<guest_user_on_account::UniqueWhereParam>,
        ) -> SetParam {
            SetParam::SetAccounts(params)
        }
        pub fn some(
            value: Vec<guest_user_on_account::WhereParam>,
        ) -> WhereParam {
            WhereParam::AccountsSome(value)
        }
        pub fn every(
            value: Vec<guest_user_on_account::WhereParam>,
        ) -> WhereParam {
            WhereParam::AccountsEvery(value)
        }
        pub fn none(
            value: Vec<guest_user_on_account::WhereParam>,
        ) -> WhereParam {
            WhereParam::AccountsNone(value)
        }
        pub enum Include {
            Select(
                guest_user_on_account::ManyArgs,
                Vec<guest_user_on_account::SelectParam>,
            ),
            Include(
                guest_user_on_account::ManyArgs,
                Vec<guest_user_on_account::IncludeParam>,
            ),
            Fetch(guest_user_on_account::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Accounts(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < guest_user_on_account :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < guest_user_on_account :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(
                    "accounts", None, args, selections,
                )
            }
            pub fn select(
                args: guest_user_on_account::ManyArgs,
                nested_selections: Vec<guest_user_on_account::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: guest_user_on_account::ManyArgs,
                nested_selections: Vec<guest_user_on_account::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                guest_user_on_account::ManyArgs,
                Vec<guest_user_on_account::SelectParam>,
            ),
            Include(
                guest_user_on_account::ManyArgs,
                Vec<guest_user_on_account::IncludeParam>,
            ),
            Fetch(guest_user_on_account::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Accounts(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < guest_user_on_account :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(
                    "accounts", None, args, selections,
                )
            }
            pub fn select(
                args: guest_user_on_account::ManyArgs,
                nested_selections: Vec<guest_user_on_account::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: guest_user_on_account::ManyArgs,
                nested_selections: Vec<guest_user_on_account::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn email_guest_role_id<T: From<UniqueWhereParam>>(
        email: String,
        guest_role_id: String,
    ) -> T {
        UniqueWhereParam::EmailGuestRoleIdEquals(email, guest_role_id).into()
    }
    pub fn create(
        email: String,
        guest_role: super::guest_role::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (String, super::guest_role::UniqueWhereParam, Vec<SetParam>) {
        (email, guest_role, _params)
    }
    pub fn create_unchecked(
        email: String,
        guest_role_id: String,
        _params: Vec<SetParam>,
    ) -> (String, String, Vec<SetParam>) {
        (email, guest_role_id, _params)
    }
    #[macro_export]
    macro_rules ! _select_guest_user { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: guest_user :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = $ crate :: prisma :: guest_user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([$ crate :: prisma :: guest_user :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: guest_user :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = $ crate :: prisma :: guest_user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([$ crate :: prisma :: guest_user :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , email , guest_role , guest_role_id , created , updated , accounts } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: guest_user :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: guest_user :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: guest_user :: select ! (@ field_serde_name ; $ field) , ", ") , + ,)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: guest_user :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guest_user :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guest_user :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "email" , "guest_role" , "guest_role_id" , "created" , "updated" , "accounts"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: guest_user :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; email) => { String } ; (@ field_type ; guest_role : $ selection_mode : ident { $ ($ selections : tt) + }) => { guest_role :: Data } ; (@ field_type ; guest_role) => { crate :: prisma :: guest_role :: Data } ; (@ field_type ; guest_role_id) => { String } ; (@ field_type ; created) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; updated) => { Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > } ; (@ field_type ; accounts : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < accounts :: Data > } ; (@ field_type ; accounts) => { Vec < crate :: prisma :: guest_user_on_account :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "GuestUser" , available relations are "id, email, guest_role, guest_role_id, created, updated, accounts")) } ; (@ field_module ; guest_role : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: guest_role :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; accounts : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: guest_user_on_account :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: guest_user :: SelectParam > :: into ($ crate :: prisma :: guest_user :: id :: Select) } ; (@ selection_field_to_selection_param ; email) => { Into :: < $ crate :: prisma :: guest_user :: SelectParam > :: into ($ crate :: prisma :: guest_user :: email :: Select) } ; (@ selection_field_to_selection_param ; guest_role $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: guest_user :: SelectParam > :: into ($ crate :: prisma :: guest_user :: guest_role :: Select :: $ selection_mode ($ crate :: prisma :: guest_role :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; guest_role $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: guest_user :: SelectParam > :: into ($ crate :: prisma :: guest_user :: guest_role :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; guest_role_id) => { Into :: < $ crate :: prisma :: guest_user :: SelectParam > :: into ($ crate :: prisma :: guest_user :: guest_role_id :: Select) } ; (@ selection_field_to_selection_param ; created) => { Into :: < $ crate :: prisma :: guest_user :: SelectParam > :: into ($ crate :: prisma :: guest_user :: created :: Select) } ; (@ selection_field_to_selection_param ; updated) => { Into :: < $ crate :: prisma :: guest_user :: SelectParam > :: into ($ crate :: prisma :: guest_user :: updated :: Select) } ; (@ selection_field_to_selection_param ; accounts $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: guest_user :: SelectParam > :: into ($ crate :: prisma :: guest_user :: accounts :: Select :: $ selection_mode ($ crate :: prisma :: guest_user_on_account :: ManyArgs :: new ($ crate :: prisma :: guest_user_on_account :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: guest_user_on_account :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; accounts $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: guest_user :: SelectParam > :: into ($ crate :: prisma :: guest_user :: accounts :: Select :: Fetch ($ crate :: prisma :: guest_user_on_account :: ManyArgs :: new ($ crate :: prisma :: guest_user_on_account :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: guest_user :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; email) => { "email" } ; (@ field_serde_name ; guest_role) => { "guest_role" } ; (@ field_serde_name ; guest_role_id) => { "guest_role_id" } ; (@ field_serde_name ; created) => { "created" } ; (@ field_serde_name ; updated) => { "updated" } ; (@ field_serde_name ; accounts) => { "accounts" } ; }
    pub use _select_guest_user as select;
    pub enum SelectParam {
        Id(id::Select),
        Email(email::Select),
        GuestRole(guest_role::Select),
        GuestRoleId(guest_role_id::Select),
        Created(created::Select),
        Updated(updated::Select),
        Accounts(accounts::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Email(data) => data.to_selection(),
                Self::GuestRole(data) => data.to_selection(),
                Self::GuestRoleId(data) => data.to_selection(),
                Self::Created(data) => data.to_selection(),
                Self::Updated(data) => data.to_selection(),
                Self::Accounts(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_guest_user { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: guest_user :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = $ crate :: prisma :: guest_user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([$ crate :: prisma :: guest_user :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < $ crate :: prisma :: guest_user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: guest_user :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = $ crate :: prisma :: guest_user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([$ crate :: prisma :: guest_user :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < $ crate :: prisma :: guest_user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { guest_role , accounts } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub email : String , pub guest_role_id : String , pub created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub updated : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , $ (pub $ field : $ crate :: prisma :: guest_user :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (email) , stringify ! (guest_role_id) , stringify ! (created) , stringify ! (updated)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: guest_user :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: guest_user :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: guest_user :: include ! (@ field_serde_name ; email) , & self . email) ? ; state . serialize_field ($ crate :: prisma :: guest_user :: include ! (@ field_serde_name ; guest_role_id) , & self . guest_role_id) ? ; state . serialize_field ($ crate :: prisma :: guest_user :: include ! (@ field_serde_name ; created) , & self . created) ? ; state . serialize_field ($ crate :: prisma :: guest_user :: include ! (@ field_serde_name ; updated) , & self . updated) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , email , guest_role_id , created , updated } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: guest_user :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: guest_user :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: guest_user :: include ! (@ field_serde_name ; email) , ", " , $ crate :: prisma :: guest_user :: include ! (@ field_serde_name ; guest_role_id) , ", " , $ crate :: prisma :: guest_user :: include ! (@ field_serde_name ; created) , ", " , $ crate :: prisma :: guest_user :: include ! (@ field_serde_name ; updated) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: guest_user :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: guest_user :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: guest_user :: include ! (@ field_serde_name ; email) => Ok (Field :: email) , $ crate :: prisma :: guest_user :: include ! (@ field_serde_name ; guest_role_id) => Ok (Field :: guest_role_id) , $ crate :: prisma :: guest_user :: include ! (@ field_serde_name ; created) => Ok (Field :: created) , $ crate :: prisma :: guest_user :: include ! (@ field_serde_name ; updated) => Ok (Field :: updated) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut email = None ; let mut guest_role_id = None ; let mut created = None ; let mut updated = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guest_user :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: email => { if email . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guest_user :: include ! (@ field_serde_name ; email))) ; } email = Some (map . next_value () ?) ; } Field :: guest_role_id => { if guest_role_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guest_user :: include ! (@ field_serde_name ; guest_role_id))) ; } guest_role_id = Some (map . next_value () ?) ; } Field :: created => { if created . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guest_user :: include ! (@ field_serde_name ; created))) ; } created = Some (map . next_value () ?) ; } Field :: updated => { if updated . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guest_user :: include ! (@ field_serde_name ; updated))) ; } updated = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guest_user :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guest_user :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guest_user :: include ! (@ field_serde_name ; id))) ? ; let email = email . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guest_user :: include ! (@ field_serde_name ; email))) ? ; let guest_role_id = guest_role_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guest_user :: include ! (@ field_serde_name ; guest_role_id))) ? ; let created = created . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guest_user :: include ! (@ field_serde_name ; created))) ? ; let updated = updated . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guest_user :: include ! (@ field_serde_name ; updated))) ? ; Ok (Data { id , email , guest_role_id , created , updated , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "email" , "guest_role" , "guest_role_id" , "created" , "updated" , "accounts"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: guest_user :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; guest_role : $ selection_mode : ident { $ ($ selections : tt) + }) => { guest_role :: Data } ; (@ field_type ; guest_role) => { crate :: prisma :: guest_role :: Data } ; (@ field_type ; accounts : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < accounts :: Data > } ; (@ field_type ; accounts) => { Vec < crate :: prisma :: guest_user_on_account :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "GuestUser" , available relations are "guest_role, accounts")) } ; (@ field_module ; guest_role : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: guest_role :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; accounts : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: guest_user_on_account :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; guest_role $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: guest_user :: IncludeParam > :: into ($ crate :: prisma :: guest_user :: guest_role :: Include :: $ selection_mode ($ crate :: prisma :: guest_role :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; guest_role $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: guest_user :: IncludeParam > :: into ($ crate :: prisma :: guest_user :: guest_role :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; accounts $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: guest_user :: IncludeParam > :: into ($ crate :: prisma :: guest_user :: accounts :: Include :: $ selection_mode ($ crate :: prisma :: guest_user_on_account :: ManyArgs :: new ($ crate :: prisma :: guest_user_on_account :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: guest_user_on_account :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; accounts $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: guest_user :: IncludeParam > :: into ($ crate :: prisma :: guest_user :: accounts :: Include :: Fetch ($ crate :: prisma :: guest_user_on_account :: ManyArgs :: new ($ crate :: prisma :: guest_user_on_account :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: guest_user :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; email) => { "email" } ; (@ field_serde_name ; guest_role) => { "guest_role" } ; (@ field_serde_name ; guest_role_id) => { "guest_role_id" } ; (@ field_serde_name ; created) => { "created" } ; (@ field_serde_name ; updated) => { "updated" } ; (@ field_serde_name ; accounts) => { "accounts" } ; }
    pub use _include_guest_user as include;
    pub enum IncludeParam {
        Id(id::Include),
        Email(email::Include),
        GuestRole(guest_role::Include),
        GuestRoleId(guest_role_id::Include),
        Created(created::Include),
        Updated(updated::Include),
        Accounts(accounts::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Email(data) => data.to_selection(),
                Self::GuestRole(data) => data.to_selection(),
                Self::GuestRoleId(data) => data.to_selection(),
                Self::Created(data) => data.to_selection(),
                Self::Updated(data) => data.to_selection(),
                Self::Accounts(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "email")]
        pub email: String,
        #[serde(rename = "guest_role")]
        pub guest_role: Option<Box<super::guest_role::Data>>,
        #[serde(rename = "guest_role_id")]
        pub guest_role_id: String,
        #[serde(rename = "created")]
        pub created: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        #[serde(rename = "updated")]
        pub updated: Option<
            ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        >,
        #[serde(rename = "accounts")]
        pub accounts: Option<Vec<super::guest_user_on_account::Data>>,
    }
    impl Data {
        pub fn guest_role(
            &self,
        ) -> Result<
            &super::guest_role::Data,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.guest_role
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(guest_role),
                ))
                .map(|v| v.as_ref())
        }
        pub fn accounts(
            &self,
        ) -> Result<
            &Vec<super::guest_user_on_account::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.accounts.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(
                    accounts
                )),
            )
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        GuestRole(super::guest_role::UniqueArgs),
        Accounts(super::guest_user_on_account::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::GuestRole(args) => {
                    let mut selections = < super :: guest_role :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(
                        "guest_role",
                        None,
                        [],
                        selections,
                    )
                }
                Self::Accounts(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: guest_user_on_account :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        "accounts",
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetEmail(String),
        ConnectGuestRole(super::guest_role::UniqueWhereParam),
        SetGuestRoleId(String),
        SetCreated(
            ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ),
        SetUpdated(
            Option<
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            >,
        ),
        ConnectAccounts(Vec<super::guest_user_on_account::UniqueWhereParam>),
        DisconnectAccounts(Vec<super::guest_user_on_account::UniqueWhereParam>),
        SetAccounts(Vec<super::guest_user_on_account::UniqueWhereParam>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self { SetParam :: SetId (value) => ("id" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetEmail (value) => ("email" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: ConnectGuestRole (where_param) => ("guest_role" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: Object ([where_param] . into_iter () . map (Into :: < super :: guest_role :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()))])) , SetParam :: SetGuestRoleId (value) => ("guest_role_id" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetCreated (value) => ("created" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value)) , SetParam :: SetUpdated (value) => ("updated" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: DateTime (value)) . unwrap_or_else (|| :: prisma_client_rust :: PrismaValue :: Null)) , SetParam :: ConnectAccounts (where_params) => ("accounts" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: guest_user_on_account :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , SetParam :: DisconnectAccounts (where_params) => ("accounts" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("disconnect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: guest_user_on_account :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , SetParam :: SetAccounts (where_params) => ("accounts" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("set" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: guest_user_on_account :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Email(::prisma_client_rust::Direction),
        GuestRoleId(::prisma_client_rust::Direction),
        Created(::prisma_client_rust::Direction),
        Updated(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
                Self::Email(direction) => (
                    "email".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
                Self::GuestRoleId(direction) => (
                    "guest_role_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
                Self::Created(direction) => (
                    "created".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
                Self::Updated(direction) => (
                    "updated".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        EmailGuestRoleIdEquals(String, String),
        Id(_prisma::read_filters::StringFilter),
        Email(_prisma::read_filters::StringFilter),
        GuestRoleIs(Vec<super::guest_role::WhereParam>),
        GuestRoleIsNot(Vec<super::guest_role::WhereParam>),
        GuestRoleId(_prisma::read_filters::StringFilter),
        Created(_prisma::read_filters::DateTimeFilter),
        Updated(_prisma::read_filters::DateTimeNullableFilter),
        AccountsSome(Vec<super::guest_user_on_account::WhereParam>),
        AccountsEvery(Vec<super::guest_user_on_account::WhereParam>),
        AccountsNone(Vec<super::guest_user_on_account::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . map (| v | vec ! [v]) . map (:: prisma_client_rust :: PrismaValue :: Object) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: EmailGuestRoleIdEquals (email , guest_role_id) => ("email_guest_role_id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("email" . to_string () , :: prisma_client_rust :: PrismaValue :: String (email)) , ("guest_role_id" . to_string () , :: prisma_client_rust :: PrismaValue :: String (guest_role_id))])) , Self :: Id (value) => ("id" , value . into ()) , Self :: Email (value) => ("email" , value . into ()) , Self :: GuestRoleIs (where_params) => ("guest_role" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("is" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: GuestRoleIsNot (where_params) => ("guest_role" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("isNot" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: GuestRoleId (value) => ("guest_role_id" , value . into ()) , Self :: Created (value) => ("created" , value . into ()) , Self :: Updated (value) => ("updated" , value . into ()) , Self :: AccountsSome (where_params) => ("accounts" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("some" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: AccountsEvery (where_params) => ("accounts" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("every" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: AccountsNone (where_params) => ("accounts" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("none" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) } ;
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        EmailGuestRoleIdEquals(String, String),
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::EmailGuestRoleIdEquals(
                    email,
                    guest_role_id,
                ) => Self::EmailGuestRoleIdEquals(email, guest_role_id),
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::StringFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = "GuestUser";
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            ["id", "email", "guest_role_id", "created", "updated"]
                .into_iter()
                .map(::prisma_client_rust::sel)
                .collect()
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            email: String,
            guest_role: super::guest_role::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(email::set(email));
            _params.push(guest_role::connect(guest_role));
            Create::new(self.client, _params)
        }
        pub fn create_many(
            self,
            data: Vec<(String, String, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(email, guest_role_id, mut _params)| {
                    _params.push(email::set(email));
                    _params.push(guest_role_id::set(guest_role_id));
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(
            self,
            _where: UniqueWhereParam,
            _params: Vec<SetParam>,
        ) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (email, guest_role, mut _params): (
                String,
                super::guest_role::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(email::set(email));
            _params.push(guest_role::connect(guest_role));
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod account_type {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::StartsWith(
                value,
            ))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("id")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("id")
            }
        }
    }
    pub mod name {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetName(value.0)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::NameEquals(value).into()
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::NotInVec(
                value,
            ))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Contains(
                value,
            ))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::StartsWith(
                value,
            ))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::EndsWith(
                value,
            ))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Name(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("name")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Name(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("name")
            }
        }
    }
    pub mod description {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetDescription(value.0)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::Description(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Description(
                _prisma::read_filters::StringFilter::Equals(value),
            )
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Description(_prisma::read_filters::StringFilter::InVec(
                value,
            ))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Description(
                _prisma::read_filters::StringFilter::NotInVec(value),
            )
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Description(_prisma::read_filters::StringFilter::Lt(
                value,
            ))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Description(_prisma::read_filters::StringFilter::Lte(
                value,
            ))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Description(_prisma::read_filters::StringFilter::Gt(
                value,
            ))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Description(_prisma::read_filters::StringFilter::Gte(
                value,
            ))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Description(
                _prisma::read_filters::StringFilter::Contains(value),
            )
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Description(
                _prisma::read_filters::StringFilter::StartsWith(value),
            )
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Description(
                _prisma::read_filters::StringFilter::EndsWith(value),
            )
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Description(_prisma::read_filters::StringFilter::Mode(
                value,
            ))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Description(_prisma::read_filters::StringFilter::Not(
                value,
            ))
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Description(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("description")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Description(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("description")
            }
        }
    }
    pub mod is_subscription {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetIsSubscription(value.0)
            }
        }
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::IsSubscription(direction)
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::IsSubscription(
                _prisma::read_filters::BoolFilter::Equals(value),
            )
        }
        pub fn not(value: bool) -> WhereParam {
            WhereParam::IsSubscription(_prisma::read_filters::BoolFilter::Not(
                value,
            ))
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::IsSubscription(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("is_subscription")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::IsSubscription(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("is_subscription")
            }
        }
    }
    pub mod is_manager {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetIsManager(value.0)
            }
        }
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::IsManager(direction)
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::IsManager(_prisma::read_filters::BoolFilter::Equals(
                value,
            ))
        }
        pub fn not(value: bool) -> WhereParam {
            WhereParam::IsManager(_prisma::read_filters::BoolFilter::Not(value))
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::IsManager(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("is_manager")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::IsManager(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("is_manager")
            }
        }
    }
    pub mod is_staff {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetIsStaff(value.0)
            }
        }
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::IsStaff(direction)
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::IsStaff(_prisma::read_filters::BoolFilter::Equals(
                value,
            ))
        }
        pub fn not(value: bool) -> WhereParam {
            WhereParam::IsStaff(_prisma::read_filters::BoolFilter::Not(value))
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::IsStaff(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("is_staff")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::IsStaff(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("is_staff")
            }
        }
    }
    pub mod accounts {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Fetch(pub account::ManyArgs);
        impl Fetch {
            pub fn with(
                mut self,
                params: impl Into<account::WithParam>,
            ) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: account::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: account::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Accounts(fetch.0)
            }
        }
        pub fn fetch(params: Vec<account::WhereParam>) -> Fetch {
            Fetch(account::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<account::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectAccounts(value.0)
            }
        }
        pub fn connect<T: From<Connect>>(
            params: Vec<account::UniqueWhereParam>,
        ) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<account::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectAccounts(params)
        }
        pub fn set(params: Vec<account::UniqueWhereParam>) -> SetParam {
            SetParam::SetAccounts(params)
        }
        pub fn some(value: Vec<account::WhereParam>) -> WhereParam {
            WhereParam::AccountsSome(value)
        }
        pub fn every(value: Vec<account::WhereParam>) -> WhereParam {
            WhereParam::AccountsEvery(value)
        }
        pub fn none(value: Vec<account::WhereParam>) -> WhereParam {
            WhereParam::AccountsNone(value)
        }
        pub enum Include {
            Select(account::ManyArgs, Vec<account::SelectParam>),
            Include(account::ManyArgs, Vec<account::IncludeParam>),
            Fetch(account::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Accounts(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < account :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < account :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(
                    "accounts", None, args, selections,
                )
            }
            pub fn select(
                args: account::ManyArgs,
                nested_selections: Vec<account::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: account::ManyArgs,
                nested_selections: Vec<account::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(account::ManyArgs, Vec<account::SelectParam>),
            Include(account::ManyArgs, Vec<account::IncludeParam>),
            Fetch(account::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Accounts(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < account :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(
                    "accounts", None, args, selections,
                )
            }
            pub fn select(
                args: account::ManyArgs,
                nested_selections: Vec<account::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: account::ManyArgs,
                nested_selections: Vec<account::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn create(
        name: String,
        description: String,
        _params: Vec<SetParam>,
    ) -> (String, String, Vec<SetParam>) {
        (name, description, _params)
    }
    pub fn create_unchecked(
        name: String,
        description: String,
        _params: Vec<SetParam>,
    ) -> (String, String, Vec<SetParam>) {
        (name, description, _params)
    }
    #[macro_export]
    macro_rules ! _select_account_type { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: account_type :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = $ crate :: prisma :: account_type :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([$ crate :: prisma :: account_type :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: account_type :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = $ crate :: prisma :: account_type :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([$ crate :: prisma :: account_type :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , name , description , is_subscription , is_manager , is_staff , accounts } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: account_type :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: account_type :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: account_type :: select ! (@ field_serde_name ; $ field) , ", ") , + ,)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: account_type :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: account_type :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: account_type :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "description" , "is_subscription" , "is_manager" , "is_staff" , "accounts"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: account_type :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; name) => { String } ; (@ field_type ; description) => { String } ; (@ field_type ; is_subscription) => { bool } ; (@ field_type ; is_manager) => { bool } ; (@ field_type ; is_staff) => { bool } ; (@ field_type ; accounts : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < accounts :: Data > } ; (@ field_type ; accounts) => { Vec < crate :: prisma :: account :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "AccountType" , available relations are "id, name, description, is_subscription, is_manager, is_staff, accounts")) } ; (@ field_module ; accounts : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: account :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: account_type :: SelectParam > :: into ($ crate :: prisma :: account_type :: id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < $ crate :: prisma :: account_type :: SelectParam > :: into ($ crate :: prisma :: account_type :: name :: Select) } ; (@ selection_field_to_selection_param ; description) => { Into :: < $ crate :: prisma :: account_type :: SelectParam > :: into ($ crate :: prisma :: account_type :: description :: Select) } ; (@ selection_field_to_selection_param ; is_subscription) => { Into :: < $ crate :: prisma :: account_type :: SelectParam > :: into ($ crate :: prisma :: account_type :: is_subscription :: Select) } ; (@ selection_field_to_selection_param ; is_manager) => { Into :: < $ crate :: prisma :: account_type :: SelectParam > :: into ($ crate :: prisma :: account_type :: is_manager :: Select) } ; (@ selection_field_to_selection_param ; is_staff) => { Into :: < $ crate :: prisma :: account_type :: SelectParam > :: into ($ crate :: prisma :: account_type :: is_staff :: Select) } ; (@ selection_field_to_selection_param ; accounts $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: account_type :: SelectParam > :: into ($ crate :: prisma :: account_type :: accounts :: Select :: $ selection_mode ($ crate :: prisma :: account :: ManyArgs :: new ($ crate :: prisma :: account :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: account :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; accounts $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: account_type :: SelectParam > :: into ($ crate :: prisma :: account_type :: accounts :: Select :: Fetch ($ crate :: prisma :: account :: ManyArgs :: new ($ crate :: prisma :: account :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: account_type :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; description) => { "description" } ; (@ field_serde_name ; is_subscription) => { "is_subscription" } ; (@ field_serde_name ; is_manager) => { "is_manager" } ; (@ field_serde_name ; is_staff) => { "is_staff" } ; (@ field_serde_name ; accounts) => { "accounts" } ; }
    pub use _select_account_type as select;
    pub enum SelectParam {
        Id(id::Select),
        Name(name::Select),
        Description(description::Select),
        IsSubscription(is_subscription::Select),
        IsManager(is_manager::Select),
        IsStaff(is_staff::Select),
        Accounts(accounts::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Description(data) => data.to_selection(),
                Self::IsSubscription(data) => data.to_selection(),
                Self::IsManager(data) => data.to_selection(),
                Self::IsStaff(data) => data.to_selection(),
                Self::Accounts(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_account_type { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: account_type :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = $ crate :: prisma :: account_type :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([$ crate :: prisma :: account_type :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < $ crate :: prisma :: account_type :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: account_type :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = $ crate :: prisma :: account_type :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([$ crate :: prisma :: account_type :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < $ crate :: prisma :: account_type :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { accounts } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub name : String , pub description : String , pub is_subscription : bool , pub is_manager : bool , pub is_staff : bool , $ (pub $ field : $ crate :: prisma :: account_type :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (name) , stringify ! (description) , stringify ! (is_subscription) , stringify ! (is_manager) , stringify ! (is_staff)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: account_type :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: account_type :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: account_type :: include ! (@ field_serde_name ; name) , & self . name) ? ; state . serialize_field ($ crate :: prisma :: account_type :: include ! (@ field_serde_name ; description) , & self . description) ? ; state . serialize_field ($ crate :: prisma :: account_type :: include ! (@ field_serde_name ; is_subscription) , & self . is_subscription) ? ; state . serialize_field ($ crate :: prisma :: account_type :: include ! (@ field_serde_name ; is_manager) , & self . is_manager) ? ; state . serialize_field ($ crate :: prisma :: account_type :: include ! (@ field_serde_name ; is_staff) , & self . is_staff) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , name , description , is_subscription , is_manager , is_staff } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: account_type :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: account_type :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: account_type :: include ! (@ field_serde_name ; name) , ", " , $ crate :: prisma :: account_type :: include ! (@ field_serde_name ; description) , ", " , $ crate :: prisma :: account_type :: include ! (@ field_serde_name ; is_subscription) , ", " , $ crate :: prisma :: account_type :: include ! (@ field_serde_name ; is_manager) , ", " , $ crate :: prisma :: account_type :: include ! (@ field_serde_name ; is_staff) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: account_type :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: account_type :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: account_type :: include ! (@ field_serde_name ; name) => Ok (Field :: name) , $ crate :: prisma :: account_type :: include ! (@ field_serde_name ; description) => Ok (Field :: description) , $ crate :: prisma :: account_type :: include ! (@ field_serde_name ; is_subscription) => Ok (Field :: is_subscription) , $ crate :: prisma :: account_type :: include ! (@ field_serde_name ; is_manager) => Ok (Field :: is_manager) , $ crate :: prisma :: account_type :: include ! (@ field_serde_name ; is_staff) => Ok (Field :: is_staff) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut name = None ; let mut description = None ; let mut is_subscription = None ; let mut is_manager = None ; let mut is_staff = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: account_type :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: account_type :: include ! (@ field_serde_name ; name))) ; } name = Some (map . next_value () ?) ; } Field :: description => { if description . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: account_type :: include ! (@ field_serde_name ; description))) ; } description = Some (map . next_value () ?) ; } Field :: is_subscription => { if is_subscription . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: account_type :: include ! (@ field_serde_name ; is_subscription))) ; } is_subscription = Some (map . next_value () ?) ; } Field :: is_manager => { if is_manager . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: account_type :: include ! (@ field_serde_name ; is_manager))) ; } is_manager = Some (map . next_value () ?) ; } Field :: is_staff => { if is_staff . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: account_type :: include ! (@ field_serde_name ; is_staff))) ; } is_staff = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: account_type :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: account_type :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: account_type :: include ! (@ field_serde_name ; id))) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: account_type :: include ! (@ field_serde_name ; name))) ? ; let description = description . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: account_type :: include ! (@ field_serde_name ; description))) ? ; let is_subscription = is_subscription . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: account_type :: include ! (@ field_serde_name ; is_subscription))) ? ; let is_manager = is_manager . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: account_type :: include ! (@ field_serde_name ; is_manager))) ? ; let is_staff = is_staff . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: account_type :: include ! (@ field_serde_name ; is_staff))) ? ; Ok (Data { id , name , description , is_subscription , is_manager , is_staff , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "description" , "is_subscription" , "is_manager" , "is_staff" , "accounts"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: account_type :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; accounts : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < accounts :: Data > } ; (@ field_type ; accounts) => { Vec < crate :: prisma :: account :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "AccountType" , available relations are "accounts")) } ; (@ field_module ; accounts : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: account :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; accounts $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: account_type :: IncludeParam > :: into ($ crate :: prisma :: account_type :: accounts :: Include :: $ selection_mode ($ crate :: prisma :: account :: ManyArgs :: new ($ crate :: prisma :: account :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: account :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; accounts $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: account_type :: IncludeParam > :: into ($ crate :: prisma :: account_type :: accounts :: Include :: Fetch ($ crate :: prisma :: account :: ManyArgs :: new ($ crate :: prisma :: account :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: account_type :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; description) => { "description" } ; (@ field_serde_name ; is_subscription) => { "is_subscription" } ; (@ field_serde_name ; is_manager) => { "is_manager" } ; (@ field_serde_name ; is_staff) => { "is_staff" } ; (@ field_serde_name ; accounts) => { "accounts" } ; }
    pub use _include_account_type as include;
    pub enum IncludeParam {
        Id(id::Include),
        Name(name::Include),
        Description(description::Include),
        IsSubscription(is_subscription::Include),
        IsManager(is_manager::Include),
        IsStaff(is_staff::Include),
        Accounts(accounts::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Description(data) => data.to_selection(),
                Self::IsSubscription(data) => data.to_selection(),
                Self::IsManager(data) => data.to_selection(),
                Self::IsStaff(data) => data.to_selection(),
                Self::Accounts(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "description")]
        pub description: String,
        #[serde(rename = "is_subscription")]
        pub is_subscription: bool,
        #[serde(rename = "is_manager")]
        pub is_manager: bool,
        #[serde(rename = "is_staff")]
        pub is_staff: bool,
        #[serde(rename = "accounts")]
        pub accounts: Option<Vec<super::account::Data>>,
    }
    impl Data {
        pub fn accounts(
            &self,
        ) -> Result<
            &Vec<super::account::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.accounts.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(
                    accounts
                )),
            )
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Accounts(super::account::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Accounts(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: account :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        "accounts",
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetName(String),
        SetDescription(String),
        SetIsSubscription(bool),
        SetIsManager(bool),
        SetIsStaff(bool),
        ConnectAccounts(Vec<super::account::UniqueWhereParam>),
        DisconnectAccounts(Vec<super::account::UniqueWhereParam>),
        SetAccounts(Vec<super::account::UniqueWhereParam>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self { SetParam :: SetId (value) => ("id" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetName (value) => ("name" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetDescription (value) => ("description" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetIsSubscription (value) => ("is_subscription" . to_string () , :: prisma_client_rust :: PrismaValue :: Boolean (value)) , SetParam :: SetIsManager (value) => ("is_manager" . to_string () , :: prisma_client_rust :: PrismaValue :: Boolean (value)) , SetParam :: SetIsStaff (value) => ("is_staff" . to_string () , :: prisma_client_rust :: PrismaValue :: Boolean (value)) , SetParam :: ConnectAccounts (where_params) => ("accounts" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: account :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , SetParam :: DisconnectAccounts (where_params) => ("accounts" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("disconnect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: account :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , SetParam :: SetAccounts (where_params) => ("accounts" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("set" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: account :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Name(::prisma_client_rust::Direction),
        Description(::prisma_client_rust::Direction),
        IsSubscription(::prisma_client_rust::Direction),
        IsManager(::prisma_client_rust::Direction),
        IsStaff(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
                Self::Name(direction) => (
                    "name".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
                Self::Description(direction) => (
                    "description".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
                Self::IsSubscription(direction) => (
                    "is_subscription".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
                Self::IsManager(direction) => (
                    "is_manager".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
                Self::IsStaff(direction) => (
                    "is_staff".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::StringFilter),
        Name(_prisma::read_filters::StringFilter),
        Description(_prisma::read_filters::StringFilter),
        IsSubscription(_prisma::read_filters::BoolFilter),
        IsManager(_prisma::read_filters::BoolFilter),
        IsStaff(_prisma::read_filters::BoolFilter),
        AccountsSome(Vec<super::account::WhereParam>),
        AccountsEvery(Vec<super::account::WhereParam>),
        AccountsNone(Vec<super::account::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . map (| v | vec ! [v]) . map (:: prisma_client_rust :: PrismaValue :: Object) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Id (value) => ("id" , value . into ()) , Self :: Name (value) => ("name" , value . into ()) , Self :: Description (value) => ("description" , value . into ()) , Self :: IsSubscription (value) => ("is_subscription" , value . into ()) , Self :: IsManager (value) => ("is_manager" , value . into ()) , Self :: IsStaff (value) => ("is_staff" , value . into ()) , Self :: AccountsSome (where_params) => ("accounts" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("some" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: AccountsEvery (where_params) => ("accounts" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("every" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: AccountsNone (where_params) => ("accounts" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("none" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) } ;
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        NameEquals(String),
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::NameEquals(value) => Self::Name(
                    _prisma::read_filters::StringFilter::Equals(value),
                ),
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::StringFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = "AccountType";
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            [
                "id",
                "name",
                "description",
                "is_subscription",
                "is_manager",
                "is_staff",
            ]
            .into_iter()
            .map(::prisma_client_rust::sel)
            .collect()
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            name: String,
            description: String,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(name::set(name));
            _params.push(description::set(description));
            Create::new(self.client, _params)
        }
        pub fn create_many(
            self,
            data: Vec<(String, String, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(name, description, mut _params)| {
                    _params.push(name::set(name));
                    _params.push(description::set(description));
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(
            self,
            _where: UniqueWhereParam,
            _params: Vec<SetParam>,
        ) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (name, description, mut _params): (String, String, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(name::set(name));
            _params.push(description::set(description));
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod account {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::StartsWith(
                value,
            ))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("id")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("id")
            }
        }
    }
    pub mod name {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetName(value.0)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Equals(value))
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::NotInVec(
                value,
            ))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Contains(
                value,
            ))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::StartsWith(
                value,
            ))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::EndsWith(
                value,
            ))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Name(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("name")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Name(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("name")
            }
        }
    }
    pub mod owner {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Fetch(pub user::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Owner(fetch.0)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(user::UniqueArgs::new())
        }
        pub struct Connect(user::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectOwner(value.0)
            }
        }
        pub fn connect<T: From<Connect>>(value: user::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::OwnerIs(value)
        }
        pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::OwnerIsNot(value)
        }
        pub enum Include {
            Select(Vec<user::SelectParam>),
            Include(Vec<user::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Owner(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = < user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new(
                    "owner",
                    None,
                    [],
                    selections,
                )
            }
            pub fn select(nested_selections: Vec<user::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<user::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<user::SelectParam>),
            Include(Vec<user::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Owner(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new(
                    "owner",
                    None,
                    [],
                    selections,
                )
            }
            pub fn select(nested_selections: Vec<user::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<user::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod owner_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetOwnerId(value.0)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::OwnerId(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::OwnerIdEquals(value).into()
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::OwnerId(_prisma::read_filters::StringFilter::InVec(
                value,
            ))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::OwnerId(_prisma::read_filters::StringFilter::NotInVec(
                value,
            ))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::OwnerId(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::OwnerId(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::OwnerId(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::OwnerId(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::OwnerId(_prisma::read_filters::StringFilter::Contains(
                value,
            ))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::OwnerId(
                _prisma::read_filters::StringFilter::StartsWith(value),
            )
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::OwnerId(_prisma::read_filters::StringFilter::EndsWith(
                value,
            ))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::OwnerId(_prisma::read_filters::StringFilter::Mode(
                value,
            ))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::OwnerId(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::OwnerId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("owner_id")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::OwnerId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("owner_id")
            }
        }
    }
    pub mod account_type {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Fetch(pub account_type::UniqueArgs);
        impl Fetch {
            pub fn with(
                mut self,
                params: impl Into<account_type::WithParam>,
            ) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::AccountType(fetch.0)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(account_type::UniqueArgs::new())
        }
        pub struct Connect(account_type::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectAccountType(value.0)
            }
        }
        pub fn connect<T: From<Connect>>(
            value: account_type::UniqueWhereParam,
        ) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<account_type::WhereParam>) -> WhereParam {
            WhereParam::AccountTypeIs(value)
        }
        pub fn is_not(value: Vec<account_type::WhereParam>) -> WhereParam {
            WhereParam::AccountTypeIsNot(value)
        }
        pub enum Include {
            Select(Vec<account_type::SelectParam>),
            Include(Vec<account_type::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::AccountType(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = < account_type :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < account_type :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new(
                    "account_type",
                    None,
                    [],
                    selections,
                )
            }
            pub fn select(
                nested_selections: Vec<account_type::SelectParam>,
            ) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(
                nested_selections: Vec<account_type::IncludeParam>,
            ) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<account_type::SelectParam>),
            Include(Vec<account_type::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::AccountType(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < account_type :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new(
                    "account_type",
                    None,
                    [],
                    selections,
                )
            }
            pub fn select(
                nested_selections: Vec<account_type::SelectParam>,
            ) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(
                nested_selections: Vec<account_type::IncludeParam>,
            ) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod account_type_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetAccountTypeId(value.0)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::AccountTypeId(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::AccountTypeId(
                _prisma::read_filters::StringFilter::Equals(value),
            )
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AccountTypeId(
                _prisma::read_filters::StringFilter::InVec(value),
            )
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AccountTypeId(
                _prisma::read_filters::StringFilter::NotInVec(value),
            )
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::AccountTypeId(_prisma::read_filters::StringFilter::Lt(
                value,
            ))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::AccountTypeId(_prisma::read_filters::StringFilter::Lte(
                value,
            ))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::AccountTypeId(_prisma::read_filters::StringFilter::Gt(
                value,
            ))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::AccountTypeId(_prisma::read_filters::StringFilter::Gte(
                value,
            ))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::AccountTypeId(
                _prisma::read_filters::StringFilter::Contains(value),
            )
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::AccountTypeId(
                _prisma::read_filters::StringFilter::StartsWith(value),
            )
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::AccountTypeId(
                _prisma::read_filters::StringFilter::EndsWith(value),
            )
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::AccountTypeId(
                _prisma::read_filters::StringFilter::Mode(value),
            )
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::AccountTypeId(_prisma::read_filters::StringFilter::Not(
                value,
            ))
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::AccountTypeId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("account_type_id")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::AccountTypeId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("account_type_id")
            }
        }
    }
    pub mod created {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(
            pub  ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        );
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreated(value.0)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::Created(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Created(_prisma::read_filters::DateTimeFilter::Equals(
                value,
            ))
        }
        pub fn in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            >,
        ) -> WhereParam {
            WhereParam::Created(_prisma::read_filters::DateTimeFilter::InVec(
                value,
            ))
        }
        pub fn not_in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            >,
        ) -> WhereParam {
            WhereParam::Created(
                _prisma::read_filters::DateTimeFilter::NotInVec(value),
            )
        }
        pub fn lt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Created(_prisma::read_filters::DateTimeFilter::Lt(
                value,
            ))
        }
        pub fn lte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Created(_prisma::read_filters::DateTimeFilter::Lte(
                value,
            ))
        }
        pub fn gt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Created(_prisma::read_filters::DateTimeFilter::Gt(
                value,
            ))
        }
        pub fn gte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Created(_prisma::read_filters::DateTimeFilter::Gte(
                value,
            ))
        }
        pub fn not(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Created(_prisma::read_filters::DateTimeFilter::Not(
                value,
            ))
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Created(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("created")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Created(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("created")
            }
        }
    }
    pub mod updated {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(
            pub  Option<
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            >,
        );
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUpdated(value.0)
            }
        }
        pub fn set<T: From<Set>>(
            value: Option<
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::Updated(direction)
        }
        pub fn equals(
            value: Option<
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            >,
        ) -> WhereParam {
            WhereParam::Updated(
                _prisma::read_filters::DateTimeNullableFilter::Equals(value),
            )
        }
        pub fn in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            >,
        ) -> WhereParam {
            WhereParam::Updated(
                _prisma::read_filters::DateTimeNullableFilter::InVec(value),
            )
        }
        pub fn not_in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            >,
        ) -> WhereParam {
            WhereParam::Updated(
                _prisma::read_filters::DateTimeNullableFilter::NotInVec(value),
            )
        }
        pub fn lt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Updated(
                _prisma::read_filters::DateTimeNullableFilter::Lt(value),
            )
        }
        pub fn lte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Updated(
                _prisma::read_filters::DateTimeNullableFilter::Lte(value),
            )
        }
        pub fn gt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Updated(
                _prisma::read_filters::DateTimeNullableFilter::Gt(value),
            )
        }
        pub fn gte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Updated(
                _prisma::read_filters::DateTimeNullableFilter::Gte(value),
            )
        }
        pub fn not(
            value: Option<
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            >,
        ) -> WhereParam {
            WhereParam::Updated(
                _prisma::read_filters::DateTimeNullableFilter::Not(value),
            )
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Updated(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("updated")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Updated(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("updated")
            }
        }
    }
    pub mod is_active {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetIsActive(value.0)
            }
        }
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::IsActive(direction)
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::IsActive(_prisma::read_filters::BoolFilter::Equals(
                value,
            ))
        }
        pub fn not(value: bool) -> WhereParam {
            WhereParam::IsActive(_prisma::read_filters::BoolFilter::Not(value))
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::IsActive(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("is_active")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::IsActive(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("is_active")
            }
        }
    }
    pub mod is_checked {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetIsChecked(value.0)
            }
        }
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::IsChecked(direction)
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::IsChecked(_prisma::read_filters::BoolFilter::Equals(
                value,
            ))
        }
        pub fn not(value: bool) -> WhereParam {
            WhereParam::IsChecked(_prisma::read_filters::BoolFilter::Not(value))
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::IsChecked(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("is_checked")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::IsChecked(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("is_checked")
            }
        }
    }
    pub mod is_archived {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetIsArchived(value.0)
            }
        }
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::IsArchived(direction)
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::IsArchived(_prisma::read_filters::BoolFilter::Equals(
                value,
            ))
        }
        pub fn not(value: bool) -> WhereParam {
            WhereParam::IsArchived(_prisma::read_filters::BoolFilter::Not(
                value,
            ))
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::IsArchived(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("is_archived")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::IsArchived(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("is_archived")
            }
        }
    }
    pub mod guest_users {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Fetch(pub guest_user_on_account::ManyArgs);
        impl Fetch {
            pub fn with(
                mut self,
                params: impl Into<guest_user_on_account::WithParam>,
            ) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(
                mut self,
                param: guest_user_on_account::OrderByParam,
            ) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(
                mut self,
                value: guest_user_on_account::UniqueWhereParam,
            ) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::GuestUsers(fetch.0)
            }
        }
        pub fn fetch(params: Vec<guest_user_on_account::WhereParam>) -> Fetch {
            Fetch(guest_user_on_account::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<guest_user_on_account::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectGuestUsers(value.0)
            }
        }
        pub fn connect<T: From<Connect>>(
            params: Vec<guest_user_on_account::UniqueWhereParam>,
        ) -> T {
            Connect(params).into()
        }
        pub fn disconnect(
            params: Vec<guest_user_on_account::UniqueWhereParam>,
        ) -> SetParam {
            SetParam::DisconnectGuestUsers(params)
        }
        pub fn set(
            params: Vec<guest_user_on_account::UniqueWhereParam>,
        ) -> SetParam {
            SetParam::SetGuestUsers(params)
        }
        pub fn some(
            value: Vec<guest_user_on_account::WhereParam>,
        ) -> WhereParam {
            WhereParam::GuestUsersSome(value)
        }
        pub fn every(
            value: Vec<guest_user_on_account::WhereParam>,
        ) -> WhereParam {
            WhereParam::GuestUsersEvery(value)
        }
        pub fn none(
            value: Vec<guest_user_on_account::WhereParam>,
        ) -> WhereParam {
            WhereParam::GuestUsersNone(value)
        }
        pub enum Include {
            Select(
                guest_user_on_account::ManyArgs,
                Vec<guest_user_on_account::SelectParam>,
            ),
            Include(
                guest_user_on_account::ManyArgs,
                Vec<guest_user_on_account::IncludeParam>,
            ),
            Fetch(guest_user_on_account::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::GuestUsers(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < guest_user_on_account :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < guest_user_on_account :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(
                    "guest_users",
                    None,
                    args,
                    selections,
                )
            }
            pub fn select(
                args: guest_user_on_account::ManyArgs,
                nested_selections: Vec<guest_user_on_account::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: guest_user_on_account::ManyArgs,
                nested_selections: Vec<guest_user_on_account::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                guest_user_on_account::ManyArgs,
                Vec<guest_user_on_account::SelectParam>,
            ),
            Include(
                guest_user_on_account::ManyArgs,
                Vec<guest_user_on_account::IncludeParam>,
            ),
            Fetch(guest_user_on_account::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::GuestUsers(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < guest_user_on_account :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(
                    "guest_users",
                    None,
                    args,
                    selections,
                )
            }
            pub fn select(
                args: guest_user_on_account::ManyArgs,
                nested_selections: Vec<guest_user_on_account::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: guest_user_on_account::ManyArgs,
                nested_selections: Vec<guest_user_on_account::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn name_owner_id<T: From<UniqueWhereParam>>(
        name: String,
        owner_id: String,
    ) -> T {
        UniqueWhereParam::NameOwnerIdEquals(name, owner_id).into()
    }
    pub fn create(
        name: String,
        owner: super::user::UniqueWhereParam,
        account_type: super::account_type::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        String,
        super::user::UniqueWhereParam,
        super::account_type::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (name, owner, account_type, _params)
    }
    pub fn create_unchecked(
        name: String,
        owner_id: String,
        account_type_id: String,
        _params: Vec<SetParam>,
    ) -> (String, String, String, Vec<SetParam>) {
        (name, owner_id, account_type_id, _params)
    }
    #[macro_export]
    macro_rules ! _select_account { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: account :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = $ crate :: prisma :: account :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([$ crate :: prisma :: account :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: account :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = $ crate :: prisma :: account :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([$ crate :: prisma :: account :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , name , owner , owner_id , account_type , account_type_id , created , updated , is_active , is_checked , is_archived , guest_users } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: account :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: account :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: account :: select ! (@ field_serde_name ; $ field) , ", ") , + ,)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: account :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: account :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: account :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "owner" , "owner_id" , "account_type" , "account_type_id" , "created" , "updated" , "is_active" , "is_checked" , "is_archived" , "guest_users"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: account :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; name) => { String } ; (@ field_type ; owner : $ selection_mode : ident { $ ($ selections : tt) + }) => { owner :: Data } ; (@ field_type ; owner) => { crate :: prisma :: user :: Data } ; (@ field_type ; owner_id) => { String } ; (@ field_type ; account_type : $ selection_mode : ident { $ ($ selections : tt) + }) => { account_type :: Data } ; (@ field_type ; account_type) => { crate :: prisma :: account_type :: Data } ; (@ field_type ; account_type_id) => { String } ; (@ field_type ; created) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; updated) => { Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > } ; (@ field_type ; is_active) => { bool } ; (@ field_type ; is_checked) => { bool } ; (@ field_type ; is_archived) => { bool } ; (@ field_type ; guest_users : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < guest_users :: Data > } ; (@ field_type ; guest_users) => { Vec < crate :: prisma :: guest_user_on_account :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Account" , available relations are "id, name, owner, owner_id, account_type, account_type_id, created, updated, is_active, is_checked, is_archived, guest_users")) } ; (@ field_module ; owner : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: user :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; account_type : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: account_type :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; guest_users : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: guest_user_on_account :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: account :: SelectParam > :: into ($ crate :: prisma :: account :: id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < $ crate :: prisma :: account :: SelectParam > :: into ($ crate :: prisma :: account :: name :: Select) } ; (@ selection_field_to_selection_param ; owner $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: account :: SelectParam > :: into ($ crate :: prisma :: account :: owner :: Select :: $ selection_mode ($ crate :: prisma :: user :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; owner $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: account :: SelectParam > :: into ($ crate :: prisma :: account :: owner :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; owner_id) => { Into :: < $ crate :: prisma :: account :: SelectParam > :: into ($ crate :: prisma :: account :: owner_id :: Select) } ; (@ selection_field_to_selection_param ; account_type $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: account :: SelectParam > :: into ($ crate :: prisma :: account :: account_type :: Select :: $ selection_mode ($ crate :: prisma :: account_type :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; account_type $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: account :: SelectParam > :: into ($ crate :: prisma :: account :: account_type :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; account_type_id) => { Into :: < $ crate :: prisma :: account :: SelectParam > :: into ($ crate :: prisma :: account :: account_type_id :: Select) } ; (@ selection_field_to_selection_param ; created) => { Into :: < $ crate :: prisma :: account :: SelectParam > :: into ($ crate :: prisma :: account :: created :: Select) } ; (@ selection_field_to_selection_param ; updated) => { Into :: < $ crate :: prisma :: account :: SelectParam > :: into ($ crate :: prisma :: account :: updated :: Select) } ; (@ selection_field_to_selection_param ; is_active) => { Into :: < $ crate :: prisma :: account :: SelectParam > :: into ($ crate :: prisma :: account :: is_active :: Select) } ; (@ selection_field_to_selection_param ; is_checked) => { Into :: < $ crate :: prisma :: account :: SelectParam > :: into ($ crate :: prisma :: account :: is_checked :: Select) } ; (@ selection_field_to_selection_param ; is_archived) => { Into :: < $ crate :: prisma :: account :: SelectParam > :: into ($ crate :: prisma :: account :: is_archived :: Select) } ; (@ selection_field_to_selection_param ; guest_users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: account :: SelectParam > :: into ($ crate :: prisma :: account :: guest_users :: Select :: $ selection_mode ($ crate :: prisma :: guest_user_on_account :: ManyArgs :: new ($ crate :: prisma :: guest_user_on_account :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: guest_user_on_account :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; guest_users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: account :: SelectParam > :: into ($ crate :: prisma :: account :: guest_users :: Select :: Fetch ($ crate :: prisma :: guest_user_on_account :: ManyArgs :: new ($ crate :: prisma :: guest_user_on_account :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: account :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; owner) => { "owner" } ; (@ field_serde_name ; owner_id) => { "owner_id" } ; (@ field_serde_name ; account_type) => { "account_type" } ; (@ field_serde_name ; account_type_id) => { "account_type_id" } ; (@ field_serde_name ; created) => { "created" } ; (@ field_serde_name ; updated) => { "updated" } ; (@ field_serde_name ; is_active) => { "is_active" } ; (@ field_serde_name ; is_checked) => { "is_checked" } ; (@ field_serde_name ; is_archived) => { "is_archived" } ; (@ field_serde_name ; guest_users) => { "guest_users" } ; }
    pub use _select_account as select;
    pub enum SelectParam {
        Id(id::Select),
        Name(name::Select),
        Owner(owner::Select),
        OwnerId(owner_id::Select),
        AccountType(account_type::Select),
        AccountTypeId(account_type_id::Select),
        Created(created::Select),
        Updated(updated::Select),
        IsActive(is_active::Select),
        IsChecked(is_checked::Select),
        IsArchived(is_archived::Select),
        GuestUsers(guest_users::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Owner(data) => data.to_selection(),
                Self::OwnerId(data) => data.to_selection(),
                Self::AccountType(data) => data.to_selection(),
                Self::AccountTypeId(data) => data.to_selection(),
                Self::Created(data) => data.to_selection(),
                Self::Updated(data) => data.to_selection(),
                Self::IsActive(data) => data.to_selection(),
                Self::IsChecked(data) => data.to_selection(),
                Self::IsArchived(data) => data.to_selection(),
                Self::GuestUsers(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_account { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: account :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = $ crate :: prisma :: account :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([$ crate :: prisma :: account :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < $ crate :: prisma :: account :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: account :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = $ crate :: prisma :: account :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([$ crate :: prisma :: account :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < $ crate :: prisma :: account :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { owner , account_type , guest_users } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub name : String , pub owner_id : String , pub account_type_id : String , pub created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub updated : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , pub is_active : bool , pub is_checked : bool , pub is_archived : bool , $ (pub $ field : $ crate :: prisma :: account :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (name) , stringify ! (owner_id) , stringify ! (account_type_id) , stringify ! (created) , stringify ! (updated) , stringify ! (is_active) , stringify ! (is_checked) , stringify ! (is_archived)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: account :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: account :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: account :: include ! (@ field_serde_name ; name) , & self . name) ? ; state . serialize_field ($ crate :: prisma :: account :: include ! (@ field_serde_name ; owner_id) , & self . owner_id) ? ; state . serialize_field ($ crate :: prisma :: account :: include ! (@ field_serde_name ; account_type_id) , & self . account_type_id) ? ; state . serialize_field ($ crate :: prisma :: account :: include ! (@ field_serde_name ; created) , & self . created) ? ; state . serialize_field ($ crate :: prisma :: account :: include ! (@ field_serde_name ; updated) , & self . updated) ? ; state . serialize_field ($ crate :: prisma :: account :: include ! (@ field_serde_name ; is_active) , & self . is_active) ? ; state . serialize_field ($ crate :: prisma :: account :: include ! (@ field_serde_name ; is_checked) , & self . is_checked) ? ; state . serialize_field ($ crate :: prisma :: account :: include ! (@ field_serde_name ; is_archived) , & self . is_archived) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , name , owner_id , account_type_id , created , updated , is_active , is_checked , is_archived } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: account :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: account :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: account :: include ! (@ field_serde_name ; name) , ", " , $ crate :: prisma :: account :: include ! (@ field_serde_name ; owner_id) , ", " , $ crate :: prisma :: account :: include ! (@ field_serde_name ; account_type_id) , ", " , $ crate :: prisma :: account :: include ! (@ field_serde_name ; created) , ", " , $ crate :: prisma :: account :: include ! (@ field_serde_name ; updated) , ", " , $ crate :: prisma :: account :: include ! (@ field_serde_name ; is_active) , ", " , $ crate :: prisma :: account :: include ! (@ field_serde_name ; is_checked) , ", " , $ crate :: prisma :: account :: include ! (@ field_serde_name ; is_archived) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: account :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: account :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: account :: include ! (@ field_serde_name ; name) => Ok (Field :: name) , $ crate :: prisma :: account :: include ! (@ field_serde_name ; owner_id) => Ok (Field :: owner_id) , $ crate :: prisma :: account :: include ! (@ field_serde_name ; account_type_id) => Ok (Field :: account_type_id) , $ crate :: prisma :: account :: include ! (@ field_serde_name ; created) => Ok (Field :: created) , $ crate :: prisma :: account :: include ! (@ field_serde_name ; updated) => Ok (Field :: updated) , $ crate :: prisma :: account :: include ! (@ field_serde_name ; is_active) => Ok (Field :: is_active) , $ crate :: prisma :: account :: include ! (@ field_serde_name ; is_checked) => Ok (Field :: is_checked) , $ crate :: prisma :: account :: include ! (@ field_serde_name ; is_archived) => Ok (Field :: is_archived) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut name = None ; let mut owner_id = None ; let mut account_type_id = None ; let mut created = None ; let mut updated = None ; let mut is_active = None ; let mut is_checked = None ; let mut is_archived = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: account :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: account :: include ! (@ field_serde_name ; name))) ; } name = Some (map . next_value () ?) ; } Field :: owner_id => { if owner_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: account :: include ! (@ field_serde_name ; owner_id))) ; } owner_id = Some (map . next_value () ?) ; } Field :: account_type_id => { if account_type_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: account :: include ! (@ field_serde_name ; account_type_id))) ; } account_type_id = Some (map . next_value () ?) ; } Field :: created => { if created . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: account :: include ! (@ field_serde_name ; created))) ; } created = Some (map . next_value () ?) ; } Field :: updated => { if updated . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: account :: include ! (@ field_serde_name ; updated))) ; } updated = Some (map . next_value () ?) ; } Field :: is_active => { if is_active . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: account :: include ! (@ field_serde_name ; is_active))) ; } is_active = Some (map . next_value () ?) ; } Field :: is_checked => { if is_checked . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: account :: include ! (@ field_serde_name ; is_checked))) ; } is_checked = Some (map . next_value () ?) ; } Field :: is_archived => { if is_archived . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: account :: include ! (@ field_serde_name ; is_archived))) ; } is_archived = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: account :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: account :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: account :: include ! (@ field_serde_name ; id))) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: account :: include ! (@ field_serde_name ; name))) ? ; let owner_id = owner_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: account :: include ! (@ field_serde_name ; owner_id))) ? ; let account_type_id = account_type_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: account :: include ! (@ field_serde_name ; account_type_id))) ? ; let created = created . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: account :: include ! (@ field_serde_name ; created))) ? ; let updated = updated . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: account :: include ! (@ field_serde_name ; updated))) ? ; let is_active = is_active . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: account :: include ! (@ field_serde_name ; is_active))) ? ; let is_checked = is_checked . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: account :: include ! (@ field_serde_name ; is_checked))) ? ; let is_archived = is_archived . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: account :: include ! (@ field_serde_name ; is_archived))) ? ; Ok (Data { id , name , owner_id , account_type_id , created , updated , is_active , is_checked , is_archived , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "owner" , "owner_id" , "account_type" , "account_type_id" , "created" , "updated" , "is_active" , "is_checked" , "is_archived" , "guest_users"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: account :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; owner : $ selection_mode : ident { $ ($ selections : tt) + }) => { owner :: Data } ; (@ field_type ; owner) => { crate :: prisma :: user :: Data } ; (@ field_type ; account_type : $ selection_mode : ident { $ ($ selections : tt) + }) => { account_type :: Data } ; (@ field_type ; account_type) => { crate :: prisma :: account_type :: Data } ; (@ field_type ; guest_users : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < guest_users :: Data > } ; (@ field_type ; guest_users) => { Vec < crate :: prisma :: guest_user_on_account :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Account" , available relations are "owner, account_type, guest_users")) } ; (@ field_module ; owner : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: user :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; account_type : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: account_type :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; guest_users : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: guest_user_on_account :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; owner $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: account :: IncludeParam > :: into ($ crate :: prisma :: account :: owner :: Include :: $ selection_mode ($ crate :: prisma :: user :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; owner $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: account :: IncludeParam > :: into ($ crate :: prisma :: account :: owner :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; account_type $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: account :: IncludeParam > :: into ($ crate :: prisma :: account :: account_type :: Include :: $ selection_mode ($ crate :: prisma :: account_type :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; account_type $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: account :: IncludeParam > :: into ($ crate :: prisma :: account :: account_type :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; guest_users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: account :: IncludeParam > :: into ($ crate :: prisma :: account :: guest_users :: Include :: $ selection_mode ($ crate :: prisma :: guest_user_on_account :: ManyArgs :: new ($ crate :: prisma :: guest_user_on_account :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: guest_user_on_account :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; guest_users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: account :: IncludeParam > :: into ($ crate :: prisma :: account :: guest_users :: Include :: Fetch ($ crate :: prisma :: guest_user_on_account :: ManyArgs :: new ($ crate :: prisma :: guest_user_on_account :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: account :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; owner) => { "owner" } ; (@ field_serde_name ; owner_id) => { "owner_id" } ; (@ field_serde_name ; account_type) => { "account_type" } ; (@ field_serde_name ; account_type_id) => { "account_type_id" } ; (@ field_serde_name ; created) => { "created" } ; (@ field_serde_name ; updated) => { "updated" } ; (@ field_serde_name ; is_active) => { "is_active" } ; (@ field_serde_name ; is_checked) => { "is_checked" } ; (@ field_serde_name ; is_archived) => { "is_archived" } ; (@ field_serde_name ; guest_users) => { "guest_users" } ; }
    pub use _include_account as include;
    pub enum IncludeParam {
        Id(id::Include),
        Name(name::Include),
        Owner(owner::Include),
        OwnerId(owner_id::Include),
        AccountType(account_type::Include),
        AccountTypeId(account_type_id::Include),
        Created(created::Include),
        Updated(updated::Include),
        IsActive(is_active::Include),
        IsChecked(is_checked::Include),
        IsArchived(is_archived::Include),
        GuestUsers(guest_users::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Owner(data) => data.to_selection(),
                Self::OwnerId(data) => data.to_selection(),
                Self::AccountType(data) => data.to_selection(),
                Self::AccountTypeId(data) => data.to_selection(),
                Self::Created(data) => data.to_selection(),
                Self::Updated(data) => data.to_selection(),
                Self::IsActive(data) => data.to_selection(),
                Self::IsChecked(data) => data.to_selection(),
                Self::IsArchived(data) => data.to_selection(),
                Self::GuestUsers(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "owner")]
        pub owner: Option<Box<super::user::Data>>,
        #[serde(rename = "owner_id")]
        pub owner_id: String,
        #[serde(rename = "account_type")]
        pub account_type: Option<Box<super::account_type::Data>>,
        #[serde(rename = "account_type_id")]
        pub account_type_id: String,
        #[serde(rename = "created")]
        pub created: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        #[serde(rename = "updated")]
        pub updated: Option<
            ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        >,
        #[serde(rename = "is_active")]
        pub is_active: bool,
        #[serde(rename = "is_checked")]
        pub is_checked: bool,
        #[serde(rename = "is_archived")]
        pub is_archived: bool,
        #[serde(rename = "guest_users")]
        pub guest_users: Option<Vec<super::guest_user_on_account::Data>>,
    }
    impl Data {
        pub fn owner(
            &self,
        ) -> Result<
            &super::user::Data,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.owner
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(owner),
                ))
                .map(|v| v.as_ref())
        }
        pub fn account_type(
            &self,
        ) -> Result<
            &super::account_type::Data,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.account_type
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(account_type),
                ))
                .map(|v| v.as_ref())
        }
        pub fn guest_users(
            &self,
        ) -> Result<
            &Vec<super::guest_user_on_account::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.guest_users.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(
                    guest_users
                )),
            )
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Owner(super::user::UniqueArgs),
        AccountType(super::account_type::UniqueArgs),
        GuestUsers(super::guest_user_on_account::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Owner(args) => {
                    let mut selections = < super :: user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(
                        "owner",
                        None,
                        [],
                        selections,
                    )
                }
                Self::AccountType(args) => {
                    let mut selections = < super :: account_type :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(
                        "account_type",
                        None,
                        [],
                        selections,
                    )
                }
                Self::GuestUsers(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: guest_user_on_account :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        "guest_users",
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetName(String),
        ConnectOwner(super::user::UniqueWhereParam),
        SetOwnerId(String),
        ConnectAccountType(super::account_type::UniqueWhereParam),
        SetAccountTypeId(String),
        SetCreated(
            ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ),
        SetUpdated(
            Option<
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            >,
        ),
        SetIsActive(bool),
        SetIsChecked(bool),
        SetIsArchived(bool),
        ConnectGuestUsers(Vec<super::guest_user_on_account::UniqueWhereParam>),
        DisconnectGuestUsers(
            Vec<super::guest_user_on_account::UniqueWhereParam>,
        ),
        SetGuestUsers(Vec<super::guest_user_on_account::UniqueWhereParam>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self { SetParam :: SetId (value) => ("id" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetName (value) => ("name" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: ConnectOwner (where_param) => ("owner" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: Object ([where_param] . into_iter () . map (Into :: < super :: user :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()))])) , SetParam :: SetOwnerId (value) => ("owner_id" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: ConnectAccountType (where_param) => ("account_type" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: Object ([where_param] . into_iter () . map (Into :: < super :: account_type :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()))])) , SetParam :: SetAccountTypeId (value) => ("account_type_id" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetCreated (value) => ("created" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value)) , SetParam :: SetUpdated (value) => ("updated" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: DateTime (value)) . unwrap_or_else (|| :: prisma_client_rust :: PrismaValue :: Null)) , SetParam :: SetIsActive (value) => ("is_active" . to_string () , :: prisma_client_rust :: PrismaValue :: Boolean (value)) , SetParam :: SetIsChecked (value) => ("is_checked" . to_string () , :: prisma_client_rust :: PrismaValue :: Boolean (value)) , SetParam :: SetIsArchived (value) => ("is_archived" . to_string () , :: prisma_client_rust :: PrismaValue :: Boolean (value)) , SetParam :: ConnectGuestUsers (where_params) => ("guest_users" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: guest_user_on_account :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , SetParam :: DisconnectGuestUsers (where_params) => ("guest_users" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("disconnect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: guest_user_on_account :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , SetParam :: SetGuestUsers (where_params) => ("guest_users" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("set" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: guest_user_on_account :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Name(::prisma_client_rust::Direction),
        OwnerId(::prisma_client_rust::Direction),
        AccountTypeId(::prisma_client_rust::Direction),
        Created(::prisma_client_rust::Direction),
        Updated(::prisma_client_rust::Direction),
        IsActive(::prisma_client_rust::Direction),
        IsChecked(::prisma_client_rust::Direction),
        IsArchived(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
                Self::Name(direction) => (
                    "name".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
                Self::OwnerId(direction) => (
                    "owner_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
                Self::AccountTypeId(direction) => (
                    "account_type_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
                Self::Created(direction) => (
                    "created".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
                Self::Updated(direction) => (
                    "updated".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
                Self::IsActive(direction) => (
                    "is_active".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
                Self::IsChecked(direction) => (
                    "is_checked".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
                Self::IsArchived(direction) => (
                    "is_archived".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        NameOwnerIdEquals(String, String),
        Id(_prisma::read_filters::StringFilter),
        Name(_prisma::read_filters::StringFilter),
        OwnerIs(Vec<super::user::WhereParam>),
        OwnerIsNot(Vec<super::user::WhereParam>),
        OwnerId(_prisma::read_filters::StringFilter),
        AccountTypeIs(Vec<super::account_type::WhereParam>),
        AccountTypeIsNot(Vec<super::account_type::WhereParam>),
        AccountTypeId(_prisma::read_filters::StringFilter),
        Created(_prisma::read_filters::DateTimeFilter),
        Updated(_prisma::read_filters::DateTimeNullableFilter),
        IsActive(_prisma::read_filters::BoolFilter),
        IsChecked(_prisma::read_filters::BoolFilter),
        IsArchived(_prisma::read_filters::BoolFilter),
        GuestUsersSome(Vec<super::guest_user_on_account::WhereParam>),
        GuestUsersEvery(Vec<super::guest_user_on_account::WhereParam>),
        GuestUsersNone(Vec<super::guest_user_on_account::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . map (| v | vec ! [v]) . map (:: prisma_client_rust :: PrismaValue :: Object) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: NameOwnerIdEquals (name , owner_id) => ("name_owner_id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("name" . to_string () , :: prisma_client_rust :: PrismaValue :: String (name)) , ("owner_id" . to_string () , :: prisma_client_rust :: PrismaValue :: String (owner_id))])) , Self :: Id (value) => ("id" , value . into ()) , Self :: Name (value) => ("name" , value . into ()) , Self :: OwnerIs (where_params) => ("owner" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("is" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: OwnerIsNot (where_params) => ("owner" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("isNot" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: OwnerId (value) => ("owner_id" , value . into ()) , Self :: AccountTypeIs (where_params) => ("account_type" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("is" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: AccountTypeIsNot (where_params) => ("account_type" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("isNot" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: AccountTypeId (value) => ("account_type_id" , value . into ()) , Self :: Created (value) => ("created" , value . into ()) , Self :: Updated (value) => ("updated" , value . into ()) , Self :: IsActive (value) => ("is_active" , value . into ()) , Self :: IsChecked (value) => ("is_checked" , value . into ()) , Self :: IsArchived (value) => ("is_archived" , value . into ()) , Self :: GuestUsersSome (where_params) => ("guest_users" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("some" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: GuestUsersEvery (where_params) => ("guest_users" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("every" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: GuestUsersNone (where_params) => ("guest_users" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("none" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) } ;
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        OwnerIdEquals(String),
        NameOwnerIdEquals(String, String),
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::OwnerIdEquals(value) => Self::OwnerId(
                    _prisma::read_filters::StringFilter::Equals(value),
                ),
                UniqueWhereParam::NameOwnerIdEquals(name, owner_id) => {
                    Self::NameOwnerIdEquals(name, owner_id)
                }
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::StringFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = "Account";
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            [
                "id",
                "name",
                "owner_id",
                "account_type_id",
                "created",
                "updated",
                "is_active",
                "is_checked",
                "is_archived",
            ]
            .into_iter()
            .map(::prisma_client_rust::sel)
            .collect()
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            name: String,
            owner: super::user::UniqueWhereParam,
            account_type: super::account_type::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(name::set(name));
            _params.push(owner::connect(owner));
            _params.push(account_type::connect(account_type));
            Create::new(self.client, _params)
        }
        pub fn create_many(
            self,
            data: Vec<(String, String, String, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(name, owner_id, account_type_id, mut _params)| {
                    _params.push(name::set(name));
                    _params.push(owner_id::set(owner_id));
                    _params.push(account_type_id::set(account_type_id));
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(
            self,
            _where: UniqueWhereParam,
            _params: Vec<SetParam>,
        ) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (name, owner, account_type, mut _params): (
                String,
                super::user::UniqueWhereParam,
                super::account_type::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(name::set(name));
            _params.push(owner::connect(owner));
            _params.push(account_type::connect(account_type));
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod guest_user_on_account {
    use super::_prisma::*;
    use super::*;
    pub mod guest_user {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Fetch(pub guest_user::UniqueArgs);
        impl Fetch {
            pub fn with(
                mut self,
                params: impl Into<guest_user::WithParam>,
            ) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::GuestUser(fetch.0)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(guest_user::UniqueArgs::new())
        }
        pub struct Connect(guest_user::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectGuestUser(value.0)
            }
        }
        pub fn connect<T: From<Connect>>(
            value: guest_user::UniqueWhereParam,
        ) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<guest_user::WhereParam>) -> WhereParam {
            WhereParam::GuestUserIs(value)
        }
        pub fn is_not(value: Vec<guest_user::WhereParam>) -> WhereParam {
            WhereParam::GuestUserIsNot(value)
        }
        pub enum Include {
            Select(Vec<guest_user::SelectParam>),
            Include(Vec<guest_user::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::GuestUser(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = < guest_user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < guest_user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new(
                    "guest_user",
                    None,
                    [],
                    selections,
                )
            }
            pub fn select(
                nested_selections: Vec<guest_user::SelectParam>,
            ) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(
                nested_selections: Vec<guest_user::IncludeParam>,
            ) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<guest_user::SelectParam>),
            Include(Vec<guest_user::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::GuestUser(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < guest_user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new(
                    "guest_user",
                    None,
                    [],
                    selections,
                )
            }
            pub fn select(
                nested_selections: Vec<guest_user::SelectParam>,
            ) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(
                nested_selections: Vec<guest_user::IncludeParam>,
            ) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod guest_user_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetGuestUserId(value.0)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::GuestUserId(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::GuestUserId(
                _prisma::read_filters::StringFilter::Equals(value),
            )
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::GuestUserId(_prisma::read_filters::StringFilter::InVec(
                value,
            ))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::GuestUserId(
                _prisma::read_filters::StringFilter::NotInVec(value),
            )
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::GuestUserId(_prisma::read_filters::StringFilter::Lt(
                value,
            ))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::GuestUserId(_prisma::read_filters::StringFilter::Lte(
                value,
            ))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::GuestUserId(_prisma::read_filters::StringFilter::Gt(
                value,
            ))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::GuestUserId(_prisma::read_filters::StringFilter::Gte(
                value,
            ))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::GuestUserId(
                _prisma::read_filters::StringFilter::Contains(value),
            )
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::GuestUserId(
                _prisma::read_filters::StringFilter::StartsWith(value),
            )
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::GuestUserId(
                _prisma::read_filters::StringFilter::EndsWith(value),
            )
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::GuestUserId(_prisma::read_filters::StringFilter::Mode(
                value,
            ))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::GuestUserId(_prisma::read_filters::StringFilter::Not(
                value,
            ))
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::GuestUserId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("guest_user_id")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::GuestUserId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("guest_user_id")
            }
        }
    }
    pub mod account {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Fetch(pub account::UniqueArgs);
        impl Fetch {
            pub fn with(
                mut self,
                params: impl Into<account::WithParam>,
            ) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Account(fetch.0)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(account::UniqueArgs::new())
        }
        pub struct Connect(account::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectAccount(value.0)
            }
        }
        pub fn connect<T: From<Connect>>(
            value: account::UniqueWhereParam,
        ) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<account::WhereParam>) -> WhereParam {
            WhereParam::AccountIs(value)
        }
        pub fn is_not(value: Vec<account::WhereParam>) -> WhereParam {
            WhereParam::AccountIsNot(value)
        }
        pub enum Include {
            Select(Vec<account::SelectParam>),
            Include(Vec<account::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Account(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = < account :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < account :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new(
                    "account",
                    None,
                    [],
                    selections,
                )
            }
            pub fn select(
                nested_selections: Vec<account::SelectParam>,
            ) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(
                nested_selections: Vec<account::IncludeParam>,
            ) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<account::SelectParam>),
            Include(Vec<account::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Account(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < account :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new(
                    "account",
                    None,
                    [],
                    selections,
                )
            }
            pub fn select(
                nested_selections: Vec<account::SelectParam>,
            ) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(
                nested_selections: Vec<account::IncludeParam>,
            ) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod account_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetAccountId(value.0)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::AccountId(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::AccountId(_prisma::read_filters::StringFilter::Equals(
                value,
            ))
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AccountId(_prisma::read_filters::StringFilter::InVec(
                value,
            ))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AccountId(
                _prisma::read_filters::StringFilter::NotInVec(value),
            )
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::AccountId(_prisma::read_filters::StringFilter::Lt(
                value,
            ))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::AccountId(_prisma::read_filters::StringFilter::Lte(
                value,
            ))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::AccountId(_prisma::read_filters::StringFilter::Gt(
                value,
            ))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::AccountId(_prisma::read_filters::StringFilter::Gte(
                value,
            ))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::AccountId(
                _prisma::read_filters::StringFilter::Contains(value),
            )
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::AccountId(
                _prisma::read_filters::StringFilter::StartsWith(value),
            )
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::AccountId(
                _prisma::read_filters::StringFilter::EndsWith(value),
            )
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::AccountId(_prisma::read_filters::StringFilter::Mode(
                value,
            ))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::AccountId(_prisma::read_filters::StringFilter::Not(
                value,
            ))
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::AccountId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("account_id")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::AccountId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("account_id")
            }
        }
    }
    pub mod created {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub struct Set(
            pub  ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        );
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreated(value.0)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(
            direction: ::prisma_client_rust::Direction,
        ) -> OrderByParam {
            OrderByParam::Created(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Created(_prisma::read_filters::DateTimeFilter::Equals(
                value,
            ))
        }
        pub fn in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            >,
        ) -> WhereParam {
            WhereParam::Created(_prisma::read_filters::DateTimeFilter::InVec(
                value,
            ))
        }
        pub fn not_in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            >,
        ) -> WhereParam {
            WhereParam::Created(
                _prisma::read_filters::DateTimeFilter::NotInVec(value),
            )
        }
        pub fn lt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Created(_prisma::read_filters::DateTimeFilter::Lt(
                value,
            ))
        }
        pub fn lte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Created(_prisma::read_filters::DateTimeFilter::Lte(
                value,
            ))
        }
        pub fn gt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Created(_prisma::read_filters::DateTimeFilter::Gt(
                value,
            ))
        }
        pub fn gte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Created(_prisma::read_filters::DateTimeFilter::Gte(
                value,
            ))
        }
        pub fn not(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Created(_prisma::read_filters::DateTimeFilter::Not(
                value,
            ))
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Created(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("created")
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Created(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel("created")
            }
        }
    }
    pub fn guest_user_id_account_id<T: From<UniqueWhereParam>>(
        guest_user_id: String,
        account_id: String,
    ) -> T {
        UniqueWhereParam::GuestUserIdAccountIdEquals(guest_user_id, account_id)
            .into()
    }
    pub fn create(
        guest_user: super::guest_user::UniqueWhereParam,
        account: super::account::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        super::guest_user::UniqueWhereParam,
        super::account::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (guest_user, account, _params)
    }
    pub fn create_unchecked(
        guest_user_id: String,
        account_id: String,
        _params: Vec<SetParam>,
    ) -> (String, String, Vec<SetParam>) {
        (guest_user_id, account_id, _params)
    }
    #[macro_export]
    macro_rules ! _select_guest_user_on_account { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: guest_user_on_account :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = $ crate :: prisma :: guest_user_on_account :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([$ crate :: prisma :: guest_user_on_account :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: guest_user_on_account :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = $ crate :: prisma :: guest_user_on_account :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([$ crate :: prisma :: guest_user_on_account :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { guest_user , guest_user_id , account , account_id , created } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: guest_user_on_account :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: guest_user_on_account :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: guest_user_on_account :: select ! (@ field_serde_name ; $ field) , ", ") , + ,)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: guest_user_on_account :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guest_user_on_account :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guest_user_on_account :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["guest_user" , "guest_user_id" , "account" , "account_id" , "created"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: guest_user_on_account :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; guest_user : $ selection_mode : ident { $ ($ selections : tt) + }) => { guest_user :: Data } ; (@ field_type ; guest_user) => { crate :: prisma :: guest_user :: Data } ; (@ field_type ; guest_user_id) => { String } ; (@ field_type ; account : $ selection_mode : ident { $ ($ selections : tt) + }) => { account :: Data } ; (@ field_type ; account) => { crate :: prisma :: account :: Data } ; (@ field_type ; account_id) => { String } ; (@ field_type ; created) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "GuestUserOnAccount" , available relations are "guest_user, guest_user_id, account, account_id, created")) } ; (@ field_module ; guest_user : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: guest_user :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; account : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: account :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; guest_user $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: guest_user_on_account :: SelectParam > :: into ($ crate :: prisma :: guest_user_on_account :: guest_user :: Select :: $ selection_mode ($ crate :: prisma :: guest_user :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; guest_user $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: guest_user_on_account :: SelectParam > :: into ($ crate :: prisma :: guest_user_on_account :: guest_user :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; guest_user_id) => { Into :: < $ crate :: prisma :: guest_user_on_account :: SelectParam > :: into ($ crate :: prisma :: guest_user_on_account :: guest_user_id :: Select) } ; (@ selection_field_to_selection_param ; account $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: guest_user_on_account :: SelectParam > :: into ($ crate :: prisma :: guest_user_on_account :: account :: Select :: $ selection_mode ($ crate :: prisma :: account :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; account $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: guest_user_on_account :: SelectParam > :: into ($ crate :: prisma :: guest_user_on_account :: account :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; account_id) => { Into :: < $ crate :: prisma :: guest_user_on_account :: SelectParam > :: into ($ crate :: prisma :: guest_user_on_account :: account_id :: Select) } ; (@ selection_field_to_selection_param ; created) => { Into :: < $ crate :: prisma :: guest_user_on_account :: SelectParam > :: into ($ crate :: prisma :: guest_user_on_account :: created :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: guest_user_on_account :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; guest_user) => { "guest_user" } ; (@ field_serde_name ; guest_user_id) => { "guest_user_id" } ; (@ field_serde_name ; account) => { "account" } ; (@ field_serde_name ; account_id) => { "account_id" } ; (@ field_serde_name ; created) => { "created" } ; }
    pub use _select_guest_user_on_account as select;
    pub enum SelectParam {
        GuestUser(guest_user::Select),
        GuestUserId(guest_user_id::Select),
        Account(account::Select),
        AccountId(account_id::Select),
        Created(created::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::GuestUser(data) => data.to_selection(),
                Self::GuestUserId(data) => data.to_selection(),
                Self::Account(data) => data.to_selection(),
                Self::AccountId(data) => data.to_selection(),
                Self::Created(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_guest_user_on_account { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: guest_user_on_account :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = $ crate :: prisma :: guest_user_on_account :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([$ crate :: prisma :: guest_user_on_account :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < $ crate :: prisma :: guest_user_on_account :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: guest_user_on_account :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = $ crate :: prisma :: guest_user_on_account :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([$ crate :: prisma :: guest_user_on_account :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < $ crate :: prisma :: guest_user_on_account :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { guest_user , account } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub guest_user_id : String , pub account_id : String , pub created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (pub $ field : $ crate :: prisma :: guest_user_on_account :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (guest_user_id) , stringify ! (account_id) , stringify ! (created)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: guest_user_on_account :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: guest_user_on_account :: include ! (@ field_serde_name ; guest_user_id) , & self . guest_user_id) ? ; state . serialize_field ($ crate :: prisma :: guest_user_on_account :: include ! (@ field_serde_name ; account_id) , & self . account_id) ? ; state . serialize_field ($ crate :: prisma :: guest_user_on_account :: include ! (@ field_serde_name ; created) , & self . created) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , guest_user_id , account_id , created } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: guest_user_on_account :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: guest_user_on_account :: include ! (@ field_serde_name ; guest_user_id) , ", " , $ crate :: prisma :: guest_user_on_account :: include ! (@ field_serde_name ; account_id) , ", " , $ crate :: prisma :: guest_user_on_account :: include ! (@ field_serde_name ; created) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: guest_user_on_account :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: guest_user_on_account :: include ! (@ field_serde_name ; guest_user_id) => Ok (Field :: guest_user_id) , $ crate :: prisma :: guest_user_on_account :: include ! (@ field_serde_name ; account_id) => Ok (Field :: account_id) , $ crate :: prisma :: guest_user_on_account :: include ! (@ field_serde_name ; created) => Ok (Field :: created) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut guest_user_id = None ; let mut account_id = None ; let mut created = None ; while let Some (key) = map . next_key () ? { match key { Field :: guest_user_id => { if guest_user_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guest_user_on_account :: include ! (@ field_serde_name ; guest_user_id))) ; } guest_user_id = Some (map . next_value () ?) ; } Field :: account_id => { if account_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guest_user_on_account :: include ! (@ field_serde_name ; account_id))) ; } account_id = Some (map . next_value () ?) ; } Field :: created => { if created . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guest_user_on_account :: include ! (@ field_serde_name ; created))) ; } created = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guest_user_on_account :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guest_user_on_account :: include ! (@ field_serde_name ; $ field))) ? ;) * let guest_user_id = guest_user_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guest_user_on_account :: include ! (@ field_serde_name ; guest_user_id))) ? ; let account_id = account_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guest_user_on_account :: include ! (@ field_serde_name ; account_id))) ? ; let created = created . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guest_user_on_account :: include ! (@ field_serde_name ; created))) ? ; Ok (Data { guest_user_id , account_id , created , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["guest_user" , "guest_user_id" , "account" , "account_id" , "created"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: guest_user_on_account :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; guest_user : $ selection_mode : ident { $ ($ selections : tt) + }) => { guest_user :: Data } ; (@ field_type ; guest_user) => { crate :: prisma :: guest_user :: Data } ; (@ field_type ; account : $ selection_mode : ident { $ ($ selections : tt) + }) => { account :: Data } ; (@ field_type ; account) => { crate :: prisma :: account :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "GuestUserOnAccount" , available relations are "guest_user, account")) } ; (@ field_module ; guest_user : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: guest_user :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; account : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: account :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; guest_user $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: guest_user_on_account :: IncludeParam > :: into ($ crate :: prisma :: guest_user_on_account :: guest_user :: Include :: $ selection_mode ($ crate :: prisma :: guest_user :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; guest_user $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: guest_user_on_account :: IncludeParam > :: into ($ crate :: prisma :: guest_user_on_account :: guest_user :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; account $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: guest_user_on_account :: IncludeParam > :: into ($ crate :: prisma :: guest_user_on_account :: account :: Include :: $ selection_mode ($ crate :: prisma :: account :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; account $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: guest_user_on_account :: IncludeParam > :: into ($ crate :: prisma :: guest_user_on_account :: account :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: guest_user_on_account :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; guest_user) => { "guest_user" } ; (@ field_serde_name ; guest_user_id) => { "guest_user_id" } ; (@ field_serde_name ; account) => { "account" } ; (@ field_serde_name ; account_id) => { "account_id" } ; (@ field_serde_name ; created) => { "created" } ; }
    pub use _include_guest_user_on_account as include;
    pub enum IncludeParam {
        GuestUser(guest_user::Include),
        GuestUserId(guest_user_id::Include),
        Account(account::Include),
        AccountId(account_id::Include),
        Created(created::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::GuestUser(data) => data.to_selection(),
                Self::GuestUserId(data) => data.to_selection(),
                Self::Account(data) => data.to_selection(),
                Self::AccountId(data) => data.to_selection(),
                Self::Created(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "guest_user")]
        pub guest_user: Option<Box<super::guest_user::Data>>,
        #[serde(rename = "guest_user_id")]
        pub guest_user_id: String,
        #[serde(rename = "account")]
        pub account: Option<Box<super::account::Data>>,
        #[serde(rename = "account_id")]
        pub account_id: String,
        #[serde(rename = "created")]
        pub created: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
    }
    impl Data {
        pub fn guest_user(
            &self,
        ) -> Result<
            &super::guest_user::Data,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.guest_user
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(guest_user),
                ))
                .map(|v| v.as_ref())
        }
        pub fn account(
            &self,
        ) -> Result<
            &super::account::Data,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.account
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(account),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        GuestUser(super::guest_user::UniqueArgs),
        Account(super::account::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::GuestUser(args) => {
                    let mut selections = < super :: guest_user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(
                        "guest_user",
                        None,
                        [],
                        selections,
                    )
                }
                Self::Account(args) => {
                    let mut selections = < super :: account :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(
                        "account",
                        None,
                        [],
                        selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        ConnectGuestUser(super::guest_user::UniqueWhereParam),
        SetGuestUserId(String),
        ConnectAccount(super::account::UniqueWhereParam),
        SetAccountId(String),
        SetCreated(
            ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self { SetParam :: ConnectGuestUser (where_param) => ("guest_user" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: Object ([where_param] . into_iter () . map (Into :: < super :: guest_user :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()))])) , SetParam :: SetGuestUserId (value) => ("guest_user_id" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: ConnectAccount (where_param) => ("account" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: Object ([where_param] . into_iter () . map (Into :: < super :: account :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()))])) , SetParam :: SetAccountId (value) => ("account_id" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetCreated (value) => ("created" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value)) }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        GuestUserId(::prisma_client_rust::Direction),
        AccountId(::prisma_client_rust::Direction),
        Created(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::GuestUserId(direction) => (
                    "guest_user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
                Self::AccountId(direction) => (
                    "account_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
                Self::Created(direction) => (
                    "created".to_string(),
                    ::prisma_client_rust::PrismaValue::String(
                        direction.to_string(),
                    ),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        GuestUserIdAccountIdEquals(String, String),
        GuestUserIs(Vec<super::guest_user::WhereParam>),
        GuestUserIsNot(Vec<super::guest_user::WhereParam>),
        GuestUserId(_prisma::read_filters::StringFilter),
        AccountIs(Vec<super::account::WhereParam>),
        AccountIsNot(Vec<super::account::WhereParam>),
        AccountId(_prisma::read_filters::StringFilter),
        Created(_prisma::read_filters::DateTimeFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . map (| v | vec ! [v]) . map (:: prisma_client_rust :: PrismaValue :: Object) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: GuestUserIdAccountIdEquals (guest_user_id , account_id) => ("guest_user_id_account_id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("guest_user_id" . to_string () , :: prisma_client_rust :: PrismaValue :: String (guest_user_id)) , ("account_id" . to_string () , :: prisma_client_rust :: PrismaValue :: String (account_id))])) , Self :: GuestUserIs (where_params) => ("guest_user" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("is" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: GuestUserIsNot (where_params) => ("guest_user" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("isNot" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: GuestUserId (value) => ("guest_user_id" , value . into ()) , Self :: AccountIs (where_params) => ("account" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("is" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: AccountIsNot (where_params) => ("account" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("isNot" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: AccountId (value) => ("account_id" , value . into ()) , Self :: Created (value) => ("created" , value . into ()) } ;
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        GuestUserIdAccountIdEquals(String, String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::GuestUserIdAccountIdEquals(
                    guest_user_id,
                    account_id,
                ) => {
                    Self::GuestUserIdAccountIdEquals(guest_user_id, account_id)
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = "GuestUserOnAccount";
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            ["guest_user_id", "account_id", "created"]
                .into_iter()
                .map(::prisma_client_rust::sel)
                .collect()
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            guest_user: super::guest_user::UniqueWhereParam,
            account: super::account::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(guest_user::connect(guest_user));
            _params.push(account::connect(account));
            Create::new(self.client, _params)
        }
        pub fn create_many(
            self,
            data: Vec<(String, String, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(guest_user_id, account_id, mut _params)| {
                    _params.push(guest_user_id::set(guest_user_id));
                    _params.push(account_id::set(account_id));
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(
            self,
            _where: UniqueWhereParam,
            _params: Vec<SetParam>,
        ) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (guest_user, account, mut _params): (
                super::guest_user::UniqueWhereParam,
                super::account::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(guest_user::connect(guest_user));
            _params.push(account::connect(account));
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod _prisma {
    pub struct PrismaClientBuilder {
        url: Option<String>,
        action_notifier: ::prisma_client_rust::ActionNotifier,
    }
    impl PrismaClientBuilder {
        fn new() -> Self {
            Self {
                url: None,
                action_notifier: ::prisma_client_rust::ActionNotifier::new(),
            }
        }
        pub fn with_url(mut self, url: String) -> Self {
            self.url = Some(url);
            self
        }
        pub async fn build(
            self,
        ) -> Result<PrismaClient, ::prisma_client_rust::NewClientError>
        {
            let internals = ::prisma_client_rust::PrismaClientInternals::new(
                self.url,
                self.action_notifier,
                super::DATAMODEL_STR,
            )
            .await?;
            Ok(PrismaClient(internals))
        }
    }
    pub struct PrismaClient(::prisma_client_rust::PrismaClientInternals);
    impl ::std::fmt::Debug for PrismaClient {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.debug_struct("PrismaClient").finish()
        }
    }
    impl PrismaClient {
        pub fn _builder() -> PrismaClientBuilder {
            PrismaClientBuilder::new()
        }
        pub fn _mock() -> (Self, ::prisma_client_rust::MockStore) {
            let (internals, store) =
                ::prisma_client_rust::PrismaClientInternals::new_mock(
                    ::prisma_client_rust::ActionNotifier::new(),
                );
            (Self(internals), store)
        }
        pub fn _query_raw<T: ::prisma_client_rust::Data>(
            &self,
            query: ::prisma_client_rust::Raw,
        ) -> ::prisma_client_rust::QueryRaw<T> {
            ::prisma_client_rust::QueryRaw::new(
                &self.0,
                query,
                super::DATABASE_STR,
            )
        }
        pub fn _execute_raw(
            &self,
            query: ::prisma_client_rust::Raw,
        ) -> ::prisma_client_rust::ExecuteRaw {
            ::prisma_client_rust::ExecuteRaw::new(
                &self.0,
                query,
                super::DATABASE_STR,
            )
        }        pub async fn _batch < 'batch , T : :: prisma_client_rust :: BatchContainer < 'batch , Marker > , Marker > (& self , queries : T) -> :: prisma_client_rust :: Result << T as :: prisma_client_rust :: BatchContainer < 'batch , Marker >> :: ReturnType >{
            ::prisma_client_rust::batch(queries, &self.0).await
        }
        pub fn _transaction(
            &self,
        ) -> ::prisma_client_rust::TransactionBuilder<Self> {
            ::prisma_client_rust::TransactionBuilder::_new(self, &self.0)
        }
        pub fn user(&self) -> super::user::Actions {
            super::user::Actions { client: &self.0 }
        }
        pub fn role(&self) -> super::role::Actions {
            super::role::Actions { client: &self.0 }
        }
        pub fn guest_role(&self) -> super::guest_role::Actions {
            super::guest_role::Actions { client: &self.0 }
        }
        pub fn guest_user(&self) -> super::guest_user::Actions {
            super::guest_user::Actions { client: &self.0 }
        }
        pub fn account_type(&self) -> super::account_type::Actions {
            super::account_type::Actions { client: &self.0 }
        }
        pub fn account(&self) -> super::account::Actions {
            super::account::Actions { client: &self.0 }
        }
        pub fn guest_user_on_account(
            &self,
        ) -> super::guest_user_on_account::Actions {
            super::guest_user_on_account::Actions { client: &self.0 }
        }
    }
    impl ::prisma_client_rust::PrismaClient for PrismaClient {
        fn internals(&self) -> &::prisma_client_rust::PrismaClientInternals {
            &self.0
        }
        fn internals_mut(
            &mut self,
        ) -> &mut ::prisma_client_rust::PrismaClientInternals {
            &mut self.0
        }
        fn with_tx_id(
            &self,
            tx_id: Option<::prisma_client_rust::query_core::TxId>,
        ) -> Self {
            Self(self.0.with_tx_id(tx_id))
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        :: serde :: Serialize,
        :: serde :: Deserialize,
        PartialEq,
        Eq,
    )]
    pub enum AccountScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "name")]
        Name,
        #[serde(rename = "owner_id")]
        OwnerId,
        #[serde(rename = "account_type_id")]
        AccountTypeId,
        #[serde(rename = "created")]
        Created,
        #[serde(rename = "updated")]
        Updated,
        #[serde(rename = "is_active")]
        IsActive,
        #[serde(rename = "is_checked")]
        IsChecked,
        #[serde(rename = "is_archived")]
        IsArchived,
    }
    impl ToString for AccountScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Name => "name".to_string(),
                Self::OwnerId => "owner_id".to_string(),
                Self::AccountTypeId => "account_type_id".to_string(),
                Self::Created => "created".to_string(),
                Self::Updated => "updated".to_string(),
                Self::IsActive => "is_active".to_string(),
                Self::IsChecked => "is_checked".to_string(),
                Self::IsArchived => "is_archived".to_string(),
            }
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        :: serde :: Serialize,
        :: serde :: Deserialize,
        PartialEq,
        Eq,
    )]
    pub enum AccountTypeScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "name")]
        Name,
        #[serde(rename = "description")]
        Description,
        #[serde(rename = "is_subscription")]
        IsSubscription,
        #[serde(rename = "is_manager")]
        IsManager,
        #[serde(rename = "is_staff")]
        IsStaff,
    }
    impl ToString for AccountTypeScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Name => "name".to_string(),
                Self::Description => "description".to_string(),
                Self::IsSubscription => "is_subscription".to_string(),
                Self::IsManager => "is_manager".to_string(),
                Self::IsStaff => "is_staff".to_string(),
            }
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        :: serde :: Serialize,
        :: serde :: Deserialize,
        PartialEq,
        Eq,
    )]
    pub enum GuestRoleScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "name")]
        Name,
        #[serde(rename = "description")]
        Description,
        #[serde(rename = "role_id")]
        RoleId,
        #[serde(rename = "permissions")]
        Permissions,
    }
    impl ToString for GuestRoleScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Name => "name".to_string(),
                Self::Description => "description".to_string(),
                Self::RoleId => "role_id".to_string(),
                Self::Permissions => "permissions".to_string(),
            }
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        :: serde :: Serialize,
        :: serde :: Deserialize,
        PartialEq,
        Eq,
    )]
    pub enum GuestUserOnAccountScalarFieldEnum {
        #[serde(rename = "guest_user_id")]
        GuestUserId,
        #[serde(rename = "account_id")]
        AccountId,
        #[serde(rename = "created")]
        Created,
    }
    impl ToString for GuestUserOnAccountScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::GuestUserId => "guest_user_id".to_string(),
                Self::AccountId => "account_id".to_string(),
                Self::Created => "created".to_string(),
            }
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        :: serde :: Serialize,
        :: serde :: Deserialize,
        PartialEq,
        Eq,
    )]
    pub enum GuestUserScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "email")]
        Email,
        #[serde(rename = "guest_role_id")]
        GuestRoleId,
        #[serde(rename = "created")]
        Created,
        #[serde(rename = "updated")]
        Updated,
    }
    impl ToString for GuestUserScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Email => "email".to_string(),
                Self::GuestRoleId => "guest_role_id".to_string(),
                Self::Created => "created".to_string(),
                Self::Updated => "updated".to_string(),
            }
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        :: serde :: Serialize,
        :: serde :: Deserialize,
        PartialEq,
        Eq,
    )]
    pub enum QueryMode {
        #[serde(rename = "default")]
        Default,
        #[serde(rename = "insensitive")]
        Insensitive,
    }
    impl ToString for QueryMode {
        fn to_string(&self) -> String {
            match self {
                Self::Default => "default".to_string(),
                Self::Insensitive => "insensitive".to_string(),
            }
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        :: serde :: Serialize,
        :: serde :: Deserialize,
        PartialEq,
        Eq,
    )]
    pub enum RoleScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "name")]
        Name,
        #[serde(rename = "description")]
        Description,
    }
    impl ToString for RoleScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Name => "name".to_string(),
                Self::Description => "description".to_string(),
            }
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        :: serde :: Serialize,
        :: serde :: Deserialize,
        PartialEq,
        Eq,
    )]
    pub enum SortOrder {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }
    impl ToString for SortOrder {
        fn to_string(&self) -> String {
            match self {
                Self::Asc => "asc".to_string(),
                Self::Desc => "desc".to_string(),
            }
        }
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        :: serde :: Serialize,
        :: serde :: Deserialize,
        PartialEq,
        Eq,
    )]
    pub enum TransactionIsolationLevel {
        #[serde(rename = "ReadUncommitted")]
        ReadUncommitted,
        #[serde(rename = "ReadCommitted")]
        ReadCommitted,
        #[serde(rename = "RepeatableRead")]
        RepeatableRead,
        #[serde(rename = "Serializable")]
        Serializable,
    }
    impl ToString for TransactionIsolationLevel {
        fn to_string(&self) -> String {
            match self {
                Self::ReadUncommitted => "ReadUncommitted".to_string(),
                Self::ReadCommitted => "ReadCommitted".to_string(),
                Self::RepeatableRead => "RepeatableRead".to_string(),
                Self::Serializable => "Serializable".to_string(),
            }
        }
    }
    impl ::prisma_client_rust::TransactionIsolationLevel
        for TransactionIsolationLevel
    {
    }
    #[derive(
        Debug,
        Clone,
        Copy,
        :: serde :: Serialize,
        :: serde :: Deserialize,
        PartialEq,
        Eq,
    )]
    pub enum UserScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "username")]
        Username,
        #[serde(rename = "email")]
        Email,
        #[serde(rename = "first_name")]
        FirstName,
        #[serde(rename = "last_name")]
        LastName,
        #[serde(rename = "is_active")]
        IsActive,
        #[serde(rename = "created")]
        Created,
        #[serde(rename = "updated")]
        Updated,
    }
    impl ToString for UserScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Username => "username".to_string(),
                Self::Email => "email".to_string(),
                Self::FirstName => "first_name".to_string(),
                Self::LastName => "last_name".to_string(),
                Self::IsActive => "is_active".to_string(),
                Self::Created => "created".to_string(),
                Self::Updated => "updated".to_string(),
            }
        }
    }
    pub mod read_filters {
        #[derive(Clone)]
        pub enum StringFilter {
            Equals(String),
            InVec(Vec<String>),
            NotInVec(Vec<String>),
            Lt(String),
            Lte(String),
            Gt(String),
            Gte(String),
            Contains(String),
            StartsWith(String),
            EndsWith(String),
            Mode(super::super::QueryMode),
            Not(String),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for StringFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self { Self :: Equals (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: InVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))]) , Self :: NotInVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))]) , Self :: Lt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Lte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Gt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Gte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Contains (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("contains" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: StartsWith (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("startsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: EndsWith (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("endsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Mode (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("mode" . to_string () , :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ()))]) , Self :: Not (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) }
            }
        }
        #[derive(Clone)]
        pub enum StringNullableFilter {
            Equals(Option<String>),
            InVec(Vec<String>),
            NotInVec(Vec<String>),
            Lt(String),
            Lte(String),
            Gt(String),
            Gte(String),
            Contains(String),
            StartsWith(String),
            EndsWith(String),
            Mode(super::super::QueryMode),
            Not(Option<String>),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for StringNullableFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self { Self :: Equals (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: String (value)) . unwrap_or_else (|| :: prisma_client_rust :: PrismaValue :: Null))]) , Self :: InVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))]) , Self :: NotInVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))]) , Self :: Lt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Lte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Gt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Gte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Contains (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("contains" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: StartsWith (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("startsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: EndsWith (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("endsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Mode (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("mode" . to_string () , :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ()))]) , Self :: Not (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: String (value)) . unwrap_or_else (|| :: prisma_client_rust :: PrismaValue :: Null))]) }
            }
        }
        #[derive(Clone)]
        pub enum BoolFilter {
            Equals(bool),
            Not(bool),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for BoolFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(
                            vec![(
                                "equals".to_string(),
                                ::prisma_client_rust::PrismaValue::Boolean(
                                    value,
                                ),
                            )],
                        )
                    }
                    Self::Not(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(
                            vec![(
                                "not".to_string(),
                                ::prisma_client_rust::PrismaValue::Boolean(
                                    value,
                                ),
                            )],
                        )
                    }
                }
            }
        }
        #[derive(Clone)]
        pub enum DateTimeFilter {
            Equals(
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            ),
            InVec(
                Vec<
                    ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                >,
            ),
            NotInVec(
                Vec<
                    ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                >,
            ),
            Lt(
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            ),
            Lte(
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            ),
            Gt(
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            ),
            Gte(
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            ),
            Not(
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            ),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for DateTimeFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self { Self :: Equals (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))]) , Self :: InVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: DateTime (v)) . collect ()))]) , Self :: NotInVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: DateTime (v)) . collect ()))]) , Self :: Lt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))]) , Self :: Lte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))]) , Self :: Gt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))]) , Self :: Gte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))]) , Self :: Not (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))]) }
            }
        }
        #[derive(Clone)]
        pub enum DateTimeNullableFilter {
            Equals(
                Option<
                    ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                >,
            ),
            InVec(
                Vec<
                    ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                >,
            ),
            NotInVec(
                Vec<
                    ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                >,
            ),
            Lt(
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            ),
            Lte(
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            ),
            Gt(
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            ),
            Gte(
                ::prisma_client_rust::chrono::DateTime<
                    ::prisma_client_rust::chrono::FixedOffset,
                >,
            ),
            Not(
                Option<
                    ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                >,
            ),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue>
            for DateTimeNullableFilter
        {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self { Self :: Equals (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: DateTime (value)) . unwrap_or_else (|| :: prisma_client_rust :: PrismaValue :: Null))]) , Self :: InVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: DateTime (v)) . collect ()))]) , Self :: NotInVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: DateTime (v)) . collect ()))]) , Self :: Lt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))]) , Self :: Lte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))]) , Self :: Gt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))]) , Self :: Gte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))]) , Self :: Not (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: DateTime (value)) . unwrap_or_else (|| :: prisma_client_rust :: PrismaValue :: Null))]) }
            }
        }
        #[derive(Clone)]
        pub enum IntListNullableFilter {
            Equals(Vec<i32>),
            Has(Option<i32>),
            HasEvery(Vec<i32>),
            HasSome(Vec<i32>),
            IsEmpty(bool),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue>
            for IntListNullableFilter
        {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self { Self :: Equals (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: Int (v as i64)) . collect ()))]) , Self :: Has (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("has" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: Int (value as i64)) . unwrap_or_else (|| :: prisma_client_rust :: PrismaValue :: Null))]) , Self :: HasEvery (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("hasEvery" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: Int (v as i64)) . collect ()))]) , Self :: HasSome (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("hasSome" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: Int (v as i64)) . collect ()))]) , Self :: IsEmpty (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("isEmpty" . to_string () , :: prisma_client_rust :: PrismaValue :: Boolean (value))]) }
            }
        }
    }
}
pub use _prisma::*;
